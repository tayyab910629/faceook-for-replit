{"file_contents":{"database.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict\nfrom supabase import create_client, Client\n\nlogger = logging.getLogger(__name__)\n\nclass SupabaseDatabase:\n    def __init__(self, supabase_url: str, supabase_key: str):\n        try:\n            self.client: Client = create_client(supabase_url, supabase_key)\n            logger.info(\"âœ“ Supabase client initialized successfully\")\n            self._init_tables()\n        except Exception as e:\n            logger.error(f\"Failed to initialize Supabase client: {e}\")\n            raise\n\n    def _init_tables(self):\n        try:\n            result = self.client.table('processed_comments').select('count').limit(1).execute()\n            logger.info(f\"âœ“ Database tables verified - {result.count if result else 0} processed comments found\")\n        except Exception as e:\n            logger.warning(f\"âš ï¸ Could not verify tables. Please create them via Supabase SQL Editor. Error: {e}\")\n            logger.info(\"Run the SQL schema from SUPABASE_SCHEMA.sql to create tables\")\n\n    def is_comment_processed(self, comment_id: str) -> bool:\n        try:\n            result = self.client.table('processed_comments').select('id').eq('comment_id', comment_id).execute()\n            return len(result.data) > 0 if result.data else False\n        except Exception as e:\n            logger.debug(f\"Database offline, allowing comment {comment_id[:8]} to be processed: {e}\")\n            return False\n\n    def add_processed_comment(self, comment_id: str, user_id: str, user_name: str, comment_text: str, response_text: str, status: str = 'success', retry_count: int = 0):\n        try:\n            data: Dict[str, str | int] = {\n                'comment_id': comment_id,\n                'user_id': user_id,\n                'user_name': user_name,\n                'comment_text': comment_text[:1000],\n                'response_text': response_text[:1000],\n                'status': status,\n                'retry_count': retry_count,\n                'timestamp': datetime.now().isoformat()\n            }\n            result = self.client.table('processed_comments').insert(data).execute()\n            logger.info(f\"âœ“ Logged processed comment: {comment_id} by {user_name}\")\n            return result\n        except Exception as e:\n            logger.warning(f\"âš ï¸  Could not log processed comment (offline mode): {e}\")\n            return None\n\n    def get_user_reply_count(self, user_id: str) -> int:\n        try:\n            result = self.client.table('user_stats').select('reply_count').eq('user_id', user_id).execute()\n            if result.data and len(result.data) > 0:\n                item = result.data[0]\n                if isinstance(item, dict):\n                    val = item.get('reply_count', 0)\n                    if isinstance(val, int):\n                        return val\n                    elif isinstance(val, str) and val.isdigit():\n                        return int(val)\n                return 0\n            return 0\n        except Exception as e:\n            logger.debug(f\"Database offline, allowing reply to user {user_id[:8]}: {e}\")\n            return 0\n\n    def get_last_reply_time(self, user_id: str) -> Optional[datetime]:\n        try:\n            result = self.client.table('user_stats').select('last_reply_time').eq('user_id', user_id).execute()\n            if result.data and len(result.data) > 0:\n                item = result.data[0]\n                if isinstance(item, dict):\n                    last_reply = item.get('last_reply_time')\n                    if isinstance(last_reply, str):\n                        return datetime.fromisoformat(last_reply.replace('Z', '+00:00'))\n            return None\n        except Exception as e:\n            logger.debug(f\"Database offline, allowing reply to user {user_id[:8]}: {e}\")\n            return None\n\n    def update_user_stats(self, user_id: str, user_name: str):\n        try:\n            now = datetime.now().isoformat()\n            existing = self.client.table('user_stats').select('user_id, reply_count').eq('user_id', user_id).execute()\n            if existing.data and len(existing.data) > 0:\n                item = existing.data[0]\n                if isinstance(item, dict):\n                    current_count = item.get('reply_count', 0)\n                    if isinstance(current_count, int):\n                        self.client.table('user_stats').update({\n                            'reply_count': current_count + 1,\n                            'last_reply_time': now,\n                            'user_name': user_name\n                        }).eq('user_id', user_id).execute()\n            else:\n                self.client.table('user_stats').insert({\n                    'user_id': user_id,\n                    'user_name': user_name,\n                    'reply_count': 1,\n                    'last_reply_time': now,\n                    'first_reply_time': now\n                }).execute()\n            logger.debug(f\"âœ“ Updated user stats for {user_name}\")\n        except Exception as e:\n            logger.debug(f\"âš ï¸  Could not update user stats (offline mode): {e}\")\n\n    def add_rate_limit_entry(self):\n        try:\n            data = {'timestamp': datetime.now().isoformat()}\n            self.client.table('rate_limit_log').insert(data).execute()\n        except Exception as e:\n            logger.debug(f\"âš ï¸  Could not log rate limit entry (offline mode): {e}\")\n\n    def get_recent_reply_count(self, window_seconds: int) -> int:\n        try:\n            cutoff_time = (datetime.now() - timedelta(seconds=window_seconds)).isoformat()\n            result = self.client.table('rate_limit_log').select('id').gte('timestamp', cutoff_time).execute()\n            return result.count if result.count is not None else 0\n        except Exception as e:\n            logger.debug(f\"Database offline, rate limiting disabled: {e}\")\n            return 0\n\n    def log_event(self, event_type: str, event_data: str, level: str = 'info'):\n        try:\n            data = {\n                'event_type': event_type,\n                'event_data': event_data[:2000],\n                'level': level,\n                'timestamp': datetime.now().isoformat()\n            }\n            self.client.table('event_log').insert(data).execute()\n        except Exception as e:\n            logger.error(f\"Error logging event: {e}\")\n\n    def clean_old_rate_limit_entries(self, window_seconds: int):\n        try:\n            cutoff_time = (datetime.now() - timedelta(seconds=window_seconds * 2)).isoformat()\n            self.client.table('rate_limit_log').delete().lte('timestamp', cutoff_time).execute()\n            logger.debug(f\"âœ“ Cleaned old rate limit entries before {cutoff_time}\")\n        except Exception as e:\n            logger.error(f\"Error cleaning rate limit entries: {e}\")\n\n    def get_statistics(self) -> Dict[str, int]:\n        try:\n            total_result = self.client.table('processed_comments').select('id').execute()\n            total_comments = total_result.count if total_result.count is not None else 0\n            unique_result = self.client.table('user_stats').select('user_id').execute()\n            unique_users = unique_result.count if unique_result.count is not None else 0\n            success_result = self.client.table('processed_comments').select('id').eq('status', 'success').execute()\n            successful = success_result.count if success_result.count is not None else 0\n            failed_result = self.client.table('processed_comments').select('id').eq('status', 'failed').execute()\n            failed = failed_result.count if failed_result.count is not None else 0\n            return {\n                'total_comments': total_comments,\n                'unique_users': unique_users,\n                'successful': successful,\n                'failed': failed\n            }\n        except Exception as e:\n            logger.error(f\"Error getting statistics: {e}\")\n            return {'total_comments': 0, 'unique_users': 0, 'successful': 0, 'failed': 0}\n\n    def get_processed_comment(self, comment_id: str) -> Optional[Dict]:\n        \"\"\"Get details about a processed comment including the reply that was sent.\"\"\"\n        try:\n            result = self.client.table('processed_comments').select('*').eq('comment_id', comment_id).order('timestamp', desc=True).limit(1).execute()\n            if result.data and len(result.data) > 0:\n                return result.data[0]\n            return None\n        except Exception as e:\n            logger.debug(f\"Error getting processed comment {comment_id[:8]}: {e}\")\n            return None\n\n    def get_reply_for_comment(self, comment_id: str) -> Optional[str]:\n        \"\"\"Get the reply text that was sent for a specific comment.\"\"\"\n        try:\n            result = self.client.table('processed_comments').select('response_text').eq('comment_id', comment_id).eq('status', 'success').order('timestamp', desc=True).limit(1).execute()\n            if result.data and len(result.data) > 0:\n                return result.data[0].get('response_text')\n            return None\n        except Exception as e:\n            logger.debug(f\"Error getting reply for comment {comment_id[:8]}: {e}\")\n            return None\n\n    def get_all_replied_comment_ids(self, limit: int = 1000) -> list[str]:\n        \"\"\"Get a list of all comment IDs that have been replied to.\"\"\"\n        try:\n            result = self.client.table('processed_comments').select('comment_id').eq('status', 'success').order('timestamp', desc=True).limit(limit).execute()\n            if result.data:\n                return [item.get('comment_id') for item in result.data if item.get('comment_id')]\n            return []\n        except Exception as e:\n            logger.debug(f\"Error getting replied comment IDs: {e}\")\n            return []\n\n    def get_recent_replies(self, hours: int = 24, limit: int = 100) -> list[Dict]:\n        \"\"\"Get recent replies within the specified hours.\"\"\"\n        try:\n            cutoff_time = (datetime.now() - timedelta(hours=hours)).isoformat()\n            result = self.client.table('processed_comments').select('*').eq('status', 'success').gte('timestamp', cutoff_time).order('timestamp', desc=True).limit(limit).execute()\n            if result.data:\n                return result.data\n            return []\n        except Exception as e:\n            logger.debug(f\"Error getting recent replies: {e}\")\n            return []\n\n    def get_replies_by_user(self, user_id: str) -> list[Dict]:\n        \"\"\"Get all replies sent to a specific user.\"\"\"\n        try:\n            result = self.client.table('processed_comments').select('*').eq('user_id', user_id).eq('status', 'success').order('timestamp', desc=True).execute()\n            if result.data:\n                return result.data\n            return []\n        except Exception as e:\n            logger.debug(f\"Error getting replies for user {user_id[:8]}: {e}\")\n            return []\n\n    def has_replied_to_comment(self, comment_id: str) -> bool:\n        \"\"\"Check if we have successfully replied to a comment (status = 'success').\"\"\"\n        try:\n            result = self.client.table('processed_comments').select('id').eq('comment_id', comment_id).eq('status', 'success').limit(1).execute()\n            return len(result.data) > 0 if result.data else False\n        except Exception as e:\n            logger.debug(f\"Error checking if replied to comment {comment_id[:8]}: {e}\")\n            return False\n\n    def close(self):\n        logger.info(\"Supabase connection closed (REST client)\")\n","size_bytes":11555},"utils/validators.py":{"content":"\"\"\"\nInput validation utilities.\n\"\"\"\nimport re\nfrom typing import Optional\n\n\ndef validate_comment_id(comment_id: str) -> bool:\n    \"\"\"Validate comment ID format.\"\"\"\n    if not comment_id or len(comment_id) < 8:\n        return False\n    # Comment IDs are typically alphanumeric hashes\n    return bool(re.match(r'^[a-zA-Z0-9_-]+$', comment_id))\n\n\ndef validate_user_id(user_id: str) -> bool:\n    \"\"\"Validate user ID format.\"\"\"\n    if not user_id or len(user_id) < 8:\n        return False\n    return bool(re.match(r'^[a-zA-Z0-9_-]+$', user_id))\n\n\ndef sanitize_text(text: Optional[str], max_length: int = 1000) -> str:\n    \"\"\"Sanitize and truncate text input.\"\"\"\n    if not text:\n        return \"\"\n\n    # Remove control characters except newlines and tabs\n    sanitized = re.sub(r'[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]', '', text)\n\n    # Truncate if needed\n    if len(sanitized) > max_length:\n        sanitized = sanitized[:max_length].rsplit(' ', 1)[0] + '...'\n\n    return sanitized.strip()\n\n\ndef validate_url(url: Optional[str]) -> bool:\n    \"\"\"Validate URL format.\"\"\"\n    if not url:\n        return False\n\n    url_pattern = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE\n    )\n    return bool(url_pattern.match(url))\n\n","size_bytes":1483},"config.py":{"content":"\"\"\"\nConfiguration management module.\nHandles all configuration loading, validation, and defaults.\n\"\"\"\nimport os\nfrom typing import TypedDict, Optional\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n\nclass DelaysConfig(TypedDict):\n    \"\"\"Configuration for various delay timings.\"\"\"\n    SHORT_MIN: float\n    SHORT_MAX: float\n    MEDIUM_MIN: float\n    MEDIUM_MAX: float\n    LONG_MIN: float\n    LONG_MAX: float\n    RELOAD_PAUSE: float\n    SCAN_INTERVAL: float\n\n\nclass BotConfig(TypedDict):\n    \"\"\"Main bot configuration.\"\"\"\n    POST_URL: Optional[str]\n    MAX_REPLIES: int\n    MAX_ITERATIONS: int\n    MY_NAME: str\n    DELAYS: DelaysConfig\n    CHROME_PROFILE: str\n    MAX_RETRIES: int\n    COOLDOWN_SECONDS: int\n    MAX_REPLIES_PER_USER: int\n    RATE_LIMIT_WINDOW: int\n    MAX_REPLIES_PER_WINDOW: int\n    REPLY_TO_THREADS: bool\n    HEADLESS: bool\n    RUN_CONTINUOUSLY: bool\n\n\nclass SupabaseConfig(TypedDict):\n    \"\"\"Supabase database configuration.\"\"\"\n    URL: Optional[str]\n    ANON_KEY: Optional[str]\n\n\nclass OpenAIConfig(TypedDict):\n    \"\"\"OpenAI API configuration.\"\"\"\n    API_KEY: Optional[str]\n    MODEL: str\n    PROMPT: str\n    TEMPERATURE: float\n    MAX_TOKENS: int\n\n\ndef get_bot_config() -> BotConfig:\n    \"\"\"Get and validate bot configuration.\"\"\"\n    return {\n        'POST_URL': os.getenv('POST_URL'),\n        'MAX_REPLIES': int(os.getenv('MAX_REPLIES', '100')),\n        'MAX_ITERATIONS': int(os.getenv('MAX_ITERATIONS', '10000')),\n        'MY_NAME': os.getenv('FB_OUR_NAME', 'Danny Nguyen'),\n        'DELAYS': {\n            'SHORT_MIN': float(os.getenv('DELAY_SHORT_MIN', '0.5')),\n            'SHORT_MAX': float(os.getenv('DELAY_SHORT_MAX', '2.0')),\n            'MEDIUM_MIN': float(os.getenv('DELAY_MEDIUM_MIN', '2.0')),\n            'MEDIUM_MAX': float(os.getenv('DELAY_MEDIUM_MAX', '5.0')),\n            'LONG_MIN': float(os.getenv('DELAY_LONG_MIN', '5.0')),\n            'LONG_MAX': float(os.getenv('DELAY_LONG_MAX', '20.0')),\n            'RELOAD_PAUSE': float(os.getenv('RELOAD_PAUSE', '180.0')),\n            'SCAN_INTERVAL': float(os.getenv('SCAN_INTERVAL', '15.0')),\n        },\n        'CHROME_PROFILE': os.getenv('CHROME_PROFILE', 'Default'),\n        'MAX_RETRIES': int(os.getenv('MAX_RETRIES', '3')),\n        'COOLDOWN_SECONDS': int(os.getenv('COOLDOWN_SECONDS', '0')),\n        'MAX_REPLIES_PER_USER': int(os.getenv('MAX_REPLIES_PER_USER', '9999')),\n        'RATE_LIMIT_WINDOW': int(os.getenv('RATE_LIMIT_WINDOW', '300')),\n        'MAX_REPLIES_PER_WINDOW': int(os.getenv('MAX_REPLIES_PER_WINDOW', '999')),\n        'REPLY_TO_THREADS': os.getenv('REPLY_TO_THREADS', 'true').lower() == 'true',\n        'HEADLESS': os.getenv('HEADLESS', 'false').lower() == 'true',\n        'RUN_CONTINUOUSLY': os.getenv('RUN_CONTINUOUSLY', 'true').lower() == 'true',\n    }\n\n\ndef get_supabase_config() -> SupabaseConfig:\n    \"\"\"Get and validate Supabase configuration.\"\"\"\n    url = os.getenv('SUPABASE_URL')\n    key = os.getenv('SUPABASE_ANON_KEY')\n\n    if not url or not key:\n        raise ValueError(\"SUPABASE_URL and SUPABASE_ANON_KEY must be set in environment\")\n\n    return {\n        'URL': url,\n        'ANON_KEY': key,\n    }\n\n\ndef get_openai_config() -> OpenAIConfig:\n    \"\"\"Get and validate OpenAI configuration.\"\"\"\n    api_key = os.getenv('OPENAI_API_KEY')\n    if not api_key:\n        raise ValueError(\"OPENAI_API_KEY must be set in environment\")\n\n    return {\n        'API_KEY': api_key,\n        'MODEL': os.getenv('OPENAI_MODEL', 'gpt-4o-mini'),\n        'PROMPT': os.getenv('OPENAI_PROMPT', 'Generate a helpful, friendly reply to this comment: ') +\n                  ' Do not include emojis or any introductory phrases or additional text.',\n        'TEMPERATURE': float(os.getenv('OPENAI_TEMPERATURE', '0.8')),\n        'MAX_TOKENS': int(os.getenv('OPENAI_MAX_TOKENS', '150')),\n    }\n\n","size_bytes":3783},"utils/logger.py":{"content":"\"\"\"\nCentralized logging configuration.\n\"\"\"\nimport os\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\n\n\ndef setup_logger(\n    name: str = __name__,\n    level: int = logging.INFO,\n    log_dir: str = 'logs'\n) -> logging.Logger:\n    \"\"\"\n    Set up a logger with file and console handlers.\n\n    Args:\n        name: Logger name\n        level: Logging level\n        log_dir: Directory for log files\n\n    Returns:\n        Configured logger instance\n    \"\"\"\n    os.makedirs(log_dir, exist_ok=True)\n\n    log_filename = os.path.join(\n        log_dir,\n        f\"facebook_reply_bot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log\"\n    )\n\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n\n    # Avoid duplicate handlers\n    if logger.handlers:\n        return logger\n\n    # File handler\n    file_handler = logging.FileHandler(log_filename, encoding='utf-8')\n    file_handler.setLevel(level)\n    file_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n    file_handler.setFormatter(file_formatter)\n\n    # Console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(level)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(levelname)s: %(message)s',\n        datefmt='%H:%M:%S'\n    )\n    console_handler.setFormatter(console_formatter)\n\n    logger.addHandler(file_handler)\n    logger.addHandler(console_handler)\n\n    return logger\n\n","size_bytes":1488},"README.md":{"content":"# fb-new-comment-bot\nFacebook comments replying bot\n","size_bytes":52},"constants.py":{"content":"\"\"\"\nApplication constants and static configuration.\n\"\"\"\nfrom typing import Final\n\n# Prompt templates for AI reply generation\nPROMPT_TEMPLATES: Final[list[str]] = [\n    'Read this Facebook post and comment carefully. Generate a relevant, helpful reply that addresses the comment in the context of the original post.\\n\\nOriginal Post: {post}\\n\\nComment: {comment}\\n\\nReply should be brief, friendly, and directly related to both the post and comment content.',\n    'Analyze this Facebook post and the comment below it. Respond appropriately based on the comment content, keeping in mind the context of the original post.\\n\\nOriginal Post: {post}\\n\\nComment: {comment}\\n\\nIf it is a question, answer it. If it is a statement, acknowledge it meaningfully. Keep the reply short and relevant to both the post and comment.',\n    'Generate a contextual reply to this comment, considering the original post it responds to.\\n\\nOriginal Post: {post}\\n\\nComment: {comment}\\n\\nMatch the tone and address the specific topic mentioned. Be genuine and concise.',\n    'Respond to this comment in a way that shows you understand both the original post and the user\\'s comment.\\n\\nOriginal Post: {post}\\n\\nComment: {comment}\\n\\nUse a friendly, conversational tone that directly relates to their message and the post context.',\n    'Create a reply that is specifically tailored to this comment, considering the original post it responds to.\\n\\nOriginal Post: {post}\\n\\nComment: {comment}\\n\\nAddress any questions, concerns, or points raised. Be authentic and helpful.',\n    # Fallback templates for when post content is not available\n    'Read this Facebook comment carefully and generate a relevant, helpful reply that directly addresses what the user is asking or commenting about. Comment: {comment}. Reply should be brief, friendly, and directly related to the comment content.',\n    'Analyze this comment and respond appropriately based on its content. If it is a question, answer it. If it is a statement, acknowledge it meaningfully. Comment: {comment}. Keep the reply short and relevant.',\n    'Generate a contextual reply to this comment. Match the tone and address the specific topic mentioned. Comment: {comment}. Be genuine and concise.',\n    'Respond to this comment in a way that shows you understand what the user is saying. Comment: {comment}. Use a friendly, conversational tone that directly relates to their message.',\n    'Create a reply that is specifically tailored to this comment content. Address any questions, concerns, or points raised. Comment: {comment}. Be authentic and helpful.'\n]\n\n# Chrome launch arguments for better stealth\nCHROME_LAUNCH_ARGS: Final[list[str]] = [\n    '--disable-blink-features=AutomationControlled',\n    '--disable-popup-blocking',\n    '--disable-notifications',\n    '--disable-dev-shm-usage',\n    '--no-sandbox',\n    '--disable-setuid-sandbox',\n    '--disable-gpu',\n    '--disable-software-rasterizer',\n    '--disable-extensions',\n    '--disable-sync',\n    '--disable-background-networking',\n    '--metrics-recording-only',\n    '--mute-audio'\n]\n\n# Facebook selectors (updated for current Facebook structure)\nFACEBOOK_SELECTORS: Final[dict[str, str]] = {\n    'main_content': \"//div[@role='main']\",\n    'comment_article': \"//div[@role='article']\",\n    'comment_text': 'div[dir=\"auto\"]',\n    'author_name': 'span.x193iq5w[dir=\"auto\"]',\n    'reply_button': \"//div[@role='button' and contains(text(), 'Reply')]\",\n    'reply_input': \"p[@dir='auto' and contains(@class, 'xdj266r')]\",\n    'submit_button': \"//div[@role='button' and @aria-label='Comment']\",\n}\n\n# Cache limits\nMAX_CACHE_SIZE: Final[int] = 100\nCACHE_CLEANUP_SIZE: Final[int] = 20\n\n# Retry configuration\nDEFAULT_MAX_RETRIES: Final[int] = 3\nDEFAULT_RETRY_DELAY: Final[float] = 1.0\n\n# Timeout values (in seconds)\nPAGE_LOAD_TIMEOUT: Final[int] = 30\nELEMENT_WAIT_TIMEOUT: Final[int] = 10\nREPLY_BOX_WAIT_TIMEOUT: Final[int] = 5\n\n","size_bytes":3913},"cmt.py":{"content":"\"\"\"\nFacebook AI Reply Bot - Production-Grade Implementation\n\nThis module implements a sophisticated Facebook comment reply bot with:\n- Robust error handling and retry logic\n- Database-backed comment tracking\n- AI-powered reply generation\n- Anti-detection mechanisms\n- Comprehensive logging and monitoring\n\nAuthor: Senior Engineering Team\n\"\"\"\nimport os\nimport random\nimport time\nimport logging\nimport json\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom typing import Tuple, Any, TypedDict, Optional, cast\nfrom contextlib import contextmanager\nfrom playwright.sync_api import sync_playwright, Locator, Page, BrowserContext, Playwright, FloatRect\nfrom openai import OpenAI\n\n# Local imports\nfrom database import SupabaseDatabase\nfrom config import get_bot_config, get_supabase_config, get_openai_config\nfrom constants import (\n    PROMPT_TEMPLATES,\n    CHROME_LAUNCH_ARGS,\n    FACEBOOK_SELECTORS,\n    MAX_CACHE_SIZE,\n    CACHE_CLEANUP_SIZE,\n    DEFAULT_MAX_RETRIES,\n    PAGE_LOAD_TIMEOUT,\n    ELEMENT_WAIT_TIMEOUT,\n)\nfrom utils.logger import setup_logger\nfrom utils.retry import retry_with_backoff\nfrom utils.validators import validate_comment_id, validate_user_id, sanitize_text, validate_url\n\nclass DelaysConfig(TypedDict):\n    SHORT_MIN: float\n    SHORT_MAX: float\n    MEDIUM_MIN: float\n    MEDIUM_MAX: float\n    LONG_MIN: float\n    LONG_MAX: float\n    RELOAD_PAUSE: float\n    SCAN_INTERVAL: float\n\nclass BotConfig(TypedDict):\n    POST_URL: str | None\n    MAX_REPLIES: int\n    MAX_ITERATIONS: int\n    MY_NAME: str\n    DELAYS: DelaysConfig\n    CHROME_PROFILE: str\n    MAX_RETRIES: int\n    COOLDOWN_SECONDS: int\n    MAX_REPLIES_PER_USER: int\n    RATE_LIMIT_WINDOW: int\n    MAX_REPLIES_PER_WINDOW: int\n    REPLY_TO_THREADS: bool\n    HEADLESS: bool\n    RUN_CONTINUOUSLY: bool\n\nclass SupabaseConfigDict(TypedDict):\n    URL: str | None\n    ANON_KEY: str | None\n\nclass OpenAIConfigDict(TypedDict):\n    API_KEY: str | None\n    MODEL: str\n    PROMPT: str\n    TEMPERATURE: float\n    MAX_TOKENS: int\n\nclass CommentData(TypedDict):\n    id: str\n    user_id: str\n    author: str | None\n    text: str\n    element: Locator\n    reply_button: Locator | None\n    timestamp: Optional[datetime]\n    priority: int\n    detected_at: datetime\n    comment_type: str\n\nclass RepliedComments(TypedDict):\n    replied: list[str]\n    user_replies: dict[str, int]\n\nclass Statistics(TypedDict):\n    total_comments: int\n    unique_users: int\n    successful: int\n    failed: int\n\nclass CommentQueue(TypedDict):\n    pending: list[CommentData]\n    processing: list[CommentData]\n    completed: list[str]\n    failed: list[str]\n\nclass DetectionMetrics(TypedDict):\n    total_scans: int\n    comments_detected: int\n    new_comments_found: int\n    processing_time_avg: float\n    last_scan_duration: float\n\n# Initialize logger\nlogger = setup_logger(__name__)\nclass FacebookAIReplyBot:\n    \"\"\"\n    Production-grade Facebook AI Reply Bot.\n\n    Features:\n    - Database-backed comment tracking\n    - AI-powered contextual replies\n    - Anti-detection mechanisms\n    - Robust error handling and retries\n    - Comprehensive logging and monitoring\n    \"\"\"\n\n    def __init__(self, config: Optional[dict[str, Any]] = None) -> None:\n        \"\"\"\n        Initialize the Facebook AI Reply Bot.\n\n        Args:\n            config: Optional configuration overrides\n\n        Raises:\n            ValueError: If required configuration is missing\n        \"\"\"\n        # Load and merge configuration\n        base_config = get_bot_config()\n        if config:\n            base_config.update(config)\n        self.config: BotConfig = cast(BotConfig, base_config)\n\n        # Validate critical configuration\n        if not validate_url(self.config.get('POST_URL')):\n            raise ValueError(\"POST_URL must be a valid URL\")\n\n        # Initialize browser components\n        self.playwright: Optional[Playwright] = None\n        self.browser: Optional[BrowserContext] = None\n        self.context: Optional[BrowserContext] = None\n        self.page: Optional[Page] = None\n\n        # Initialize data structures\n        self.comment_queue: CommentQueue = {\n            'pending': [],\n            'processing': [],\n            'completed': [],\n            'failed': []\n        }\n\n        self.detection_metrics: DetectionMetrics = {\n            'total_scans': 0,\n            'comments_detected': 0,\n            'new_comments_found': 0,\n            'processing_time_avg': 0.0,\n            'last_scan_duration': 0.0\n        }\n\n        self.known_comment_elements: set[str] = set()\n        self.last_comment_count: int = 0\n        self.last_full_scan: datetime = datetime.now()\n        self.session_processed_ids: set[str] = set()\n        self.adaptive_scan_interval: float = self.config['DELAYS']['SCAN_INTERVAL']\n        self.last_activity_time: datetime = datetime.now()\n\n        # Initialize database\n        try:\n            supabase_config = get_supabase_config()\n            self.db = SupabaseDatabase(\n                supabase_url=supabase_config['URL'] or '',\n                supabase_key=supabase_config['ANON_KEY'] or ''\n            )\n        except Exception as e:\n            logger.error(f\"Failed to initialize database: {e}\")\n            raise\n\n        # Initialize response cache with size limit\n        self.response_cache: dict[str, str] = {}\n\n        # Initialize OpenAI client\n        try:\n            openai_config = get_openai_config()\n            if not openai_config.get('API_KEY'):\n                raise ValueError(\"OPENAI_API_KEY must be set in environment\")\n            self.openai_client = OpenAI(api_key=openai_config['API_KEY'])\n            self.openai_config = openai_config  # Store for later use\n        except Exception as e:\n            logger.error(f\"Failed to initialize OpenAI client: {e}\")\n            raise\n\n        # Log startup\n        self.db.log_event('bot_startup', 'Bot initialized with Playwright + Supabase', 'info')\n        logger.info(\"âœ… Facebook AI Reply Bot initialized successfully\")\n\n        # Bot identification\n        self.bot_user_id: Optional[str] = None\n        self.post_content_cache: Optional[str] = None\n\n    def is_own_comment(self, author: str | None, user_id: str | None = None) -> bool:\n        \"\"\"Check if a comment is from the bot itself using case-insensitive name comparison and user_id.\"\"\"\n        if not author:\n            return False\n\n        # Normalize author name for comparison (case-insensitive, trimmed)\n        bot_name_normalized = (self.config['MY_NAME'] or '').strip().lower()\n        author_normalized = author.strip().lower()\n\n        # Check by name (case-insensitive)\n        if bot_name_normalized and author_normalized == bot_name_normalized:\n            return True\n\n        # Check by user_id if we have the bot's user_id stored\n        if self.bot_user_id and user_id and user_id == self.bot_user_id:\n            return True\n\n        return False\n\n    def is_user_in_queue(self, user_id: str) -> bool:\n        \"\"\"Check if a user is already in the pending or processing queue.\"\"\"\n        # Check pending queue\n        for comment in self.comment_queue['pending']:\n            if comment.get('user_id') == user_id:\n                return True\n\n        # Check processing queue\n        for comment in self.comment_queue['processing']:\n            if comment.get('user_id') == user_id:\n                return True\n\n        return False\n\n    def is_comment_id_in_queue(self, comment_id: str) -> bool:\n        \"\"\"Check if a comment_id is already in any part of the queue.\"\"\"\n        # Check pending queue\n        for comment in self.comment_queue['pending']:\n            if comment.get('id') == comment_id:\n                return True\n\n        # Check processing queue\n        for comment in self.comment_queue['processing']:\n            if comment.get('id') == comment_id:\n                return True\n\n        # Check completed/failed lists\n        if comment_id in self.comment_queue['completed']:\n            return True\n        if comment_id in self.comment_queue['failed']:\n            return True\n\n        return False\n\n    def is_browser_alive(self) -> bool:\n        \"\"\"Check if browser and page are still open and accessible.\"\"\"\n        try:\n            if not self.browser or not self.page:\n                return False\n\n            # Try to check if page is still accessible\n            try:\n                # Quick check - try to get page URL (non-blocking check)\n                _ = self.page.url\n                return True\n            except Exception:\n                return False\n        except Exception:\n            return False\n\n    def ensure_browser_alive(self) -> bool:\n        \"\"\"Ensure browser is alive, reopen if necessary.\"\"\"\n        if self.is_browser_alive():\n            return True\n\n        logger.warning(\"âš ï¸  Browser/page was closed unexpectedly, attempting to reopen...\")\n\n        try:\n            # Close any stale connections\n            try:\n                if self.browser:\n                    self.browser.close()\n            except:\n                pass\n\n            try:\n                if self.playwright:\n                    self.playwright.stop()\n            except:\n                pass\n\n            # Reinitialize browser\n            self.setup_driver()\n\n            # Reload the post page\n            post_url = self.config.get('POST_URL')\n            if post_url and self.page:\n                logger.info(f\"ðŸ”„ Reloading post page: {post_url}\")\n                self.page.goto(post_url, wait_until='domcontentloaded', timeout=PAGE_LOAD_TIMEOUT * 1000)\n                self.random_pause(2, 4)\n                self.setup_dialog_prevention()\n\n                # Re-extract post content\n                self.post_content_cache = None\n                self.get_post_content()\n\n                logger.info(\"âœ… Browser recovered successfully\")\n                return True\n            else:\n                logger.error(\"âŒ Cannot recover: POST_URL not configured\")\n                return False\n\n        except Exception as e:\n            logger.error(f\"âŒ Failed to recover browser: {e}\")\n            return False\n\n    def setup_dialog_prevention(self) -> None:\n        \"\"\"Inject JavaScript to prevent beforeunload dialogs and handle them automatically.\"\"\"\n        if not self.page:\n            return\n\n        try:\n            # Inject JavaScript to prevent and handle beforeunload dialogs\n            self.page.evaluate(\"\"\"\n                (function() {\n                    // Prevent beforeunload dialogs\n                    window.addEventListener('beforeunload', function(e) {\n                        // Cancel the event\n                        e.preventDefault();\n                        e.returnValue = '';\n                        return '';\n                    }, { capture: true });\n\n                    // Override window.onbeforeunload\n                    window.onbeforeunload = null;\n\n                    // Monitor for dialog appearance and auto-click Stay\n                    setInterval(function() {\n                        // Look for Leave Page dialog\n                        const dialogs = document.querySelectorAll('[role=\"dialog\"], [role=\"alertdialog\"]');\n                        for (let dialog of dialogs) {\n                            const dialogText = dialog.textContent || '';\n                            if (dialogText.includes('Leave Page') || dialogText.includes(\"You haven't finished\")) {\n                                // Find Stay button\n                                const buttons = dialog.querySelectorAll('div[role=\"button\"], button');\n                                for (let btn of buttons) {\n                                    const btnText = (btn.textContent || '').trim();\n                                    if (btnText.includes('Stay') || btnText.includes('Stay on Page')) {\n                                        console.log('Auto-clicking Stay button');\n                                        btn.click();\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                    }, 200);\n                })();\n            \"\"\")\n            logger.info(\"âœ… Dialog prevention JavaScript injected\")\n        except Exception as e:\n            logger.warning(f\"Could not inject dialog prevention: {e}\")\n\n    def handle_leave_page_dialog(self) -> bool:\n        \"\"\"Check for and handle the 'Leave Page?' dialog by clicking 'Stay on Page'.\n        Uses multiple methods including JavaScript injection for reliability.\n        Returns True if dialog was found and handled, False otherwise.\"\"\"\n        if not self.page:\n            return False\n\n        try:\n            # Method 1: Use JavaScript to find and click the Stay button directly\n            try:\n                result = self.page.evaluate(\"\"\"\n                    (function() {\n                        // Find all dialogs\n                        const dialogs = document.querySelectorAll('[role=\"dialog\"], [role=\"alertdialog\"], div[class*=\"dialog\"], div[class*=\"modal\"]');\n                        for (let dialog of dialogs) {\n                            const text = (dialog.textContent || '').toLowerCase();\n                            if (text.includes('leave page') || text.includes(\"you haven't finished\")) {\n                                // Find Stay button within this dialog\n                                const buttons = dialog.querySelectorAll('div[role=\"button\"], button, [class*=\"button\"]');\n                                for (let btn of buttons) {\n                                    const btnText = (btn.textContent || '').trim().toLowerCase();\n                                    if (btnText.includes('stay') && !btnText.includes('leave')) {\n                                        try {\n                                            btn.click();\n                                            return true;\n                                        } catch (e) {\n                                            // Try alternative click method\n                                            if (btn.dispatchEvent) {\n                                                btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return false;\n                    })();\n                \"\"\")\n                if result:\n                    logger.info(\"ðŸ”” Found and clicked 'Stay on Page' button via JavaScript\")\n                    time.sleep(0.3)\n                    return True\n            except Exception as e:\n                logger.debug(f\"JavaScript dialog handling failed: {e}\")\n\n            # Method 2: Try multiple XPath selectors to find the \"Stay on Page\" button\n            stay_selectors = [\n                # More specific selectors for Facebook dialogs\n                \"//div[@role='dialog']//div[@role='button' and contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n                \"//div[@role='alertdialog']//div[@role='button' and contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n                \"//div[contains(@class, 'dialog')]//div[@role='button' and contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n                \"//div[contains(text(), 'Leave Page')]//ancestor::div[@role='dialog']//div[@role='button'][contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n                \"//div[contains(text(), 'You haven't finished')]//ancestor::div[@role='dialog']//div[@role='button'][contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n                # Fallback selectors\n                \"//div[@role='button' and contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay on page')]\",\n                \"//div[@role='button' and contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n                \"//button[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'stay')]\",\n            ]\n\n            for selector in stay_selectors:\n                try:\n                    stay_button = self.page.locator(selector).first\n                    if stay_button.count() > 0:\n                        # Check if visible using JavaScript for more reliability\n                        is_visible = stay_button.evaluate(\"el => el.offsetParent !== null && window.getComputedStyle(el).display !== 'none'\")\n                        if is_visible:\n                            logger.info(\"ðŸ”” Found 'Leave Page?' dialog - clicking 'Stay on Page'\")\n                            # Try JavaScript click first (more reliable)\n                            try:\n                                stay_button.evaluate(\"el => el.click()\")\n                            except:\n                                stay_button.click(timeout=2000)\n                            time.sleep(0.3)\n                            return True\n                except Exception as e:\n                    logger.debug(f\"Selector {selector[:50]}... failed: {e}\")\n                    continue\n\n            # Method 3: Find dialog by text and then find button within it\n            try:\n                dialog_text_selectors = [\n                    \"//div[contains(text(), 'Leave Page')]\",\n                    \"//div[contains(text(), 'You haven't finished')]\",\n                    \"//*[contains(text(), 'Leave Page?')]\",\n                ]\n\n                for text_selector in dialog_text_selectors:\n                    dialog_elements = self.page.locator(text_selector).all()\n                    for dialog_elem in dialog_elements:\n                        try:\n                            # Find the dialog container\n                            dialog_container = dialog_elem.locator('xpath=./ancestor::div[@role=\"dialog\" or @role=\"alertdialog\" or contains(@class, \"dialog\")]').first\n                            if dialog_container.count() > 0:\n                                # Find Stay button within container\n                                stay_buttons = dialog_container.locator(\"//div[@role='button' | //button\").all()\n                                for btn in stay_buttons:\n                                    btn_text = (btn.text_content() or '').trim().lower()\n                                    if 'stay' in btn_text and 'leave' not in btn_text:\n                                        logger.info(\"ðŸ”” Found Stay button in dialog container\")\n                                        btn.evaluate(\"el => el.click()\")\n                                        time.sleep(0.3)\n                                        return True\n                        except:\n                            continue\n            except Exception as e:\n                logger.debug(f\"Dialog container search failed: {e}\")\n\n        except Exception as e:\n            logger.debug(f\"Error checking for Leave Page dialog: {e}\")\n\n        return False\n\n    def load_replied_comments(self):\n\n        logger.warning('load_replied_comments is deprecated. Using Supabase database now.')\n        return cast(RepliedComments, {'replied': [], 'user_replies': {}})\n    def save_replied_comments(self):\n\n        logger.debug('save_replied_comments is deprecated. Using Supabase database now.')\n    def setup_driver(self):\n\n        try:\n\n            self.playwright = sync_playwright().start()\n\n            chrome_path = os.getenv('CHROME_BINARY_PATH', '').strip().strip('\"')\n\n            launch_args = [\n                '--disable-blink-features=AutomationControlled',\n                '--disable-popup-blocking',\n                '--disable-notifications',\n                '--disable-dev-shm-usage',\n                '--no-sandbox',\n                '--disable-setuid-sandbox',\n                '--disable-gpu',\n                '--disable-software-rasterizer',\n                '--disable-extensions',\n                '--disable-sync',\n                '--disable-background-networking',\n                '--metrics-recording-only',\n                '--mute-audio'\n            ]\n\n            headless = self.config.get('HEADLESS', False)\n            if headless:\n                logger.info('Running in HEADLESS mode (background)')\n            else:\n                logger.info('Running with visible browser')\n\n            user_data_dir = os.path.join(os.getcwd(), 'facebook_user_data')\n            os.makedirs(user_data_dir, exist_ok=True)\n            logger.info(f'Using persistent user data directory: {user_data_dir}')\n\n            if chrome_path and os.path.exists(chrome_path):\n                logger.info(f'Using portable Chrome at: {chrome_path}')\n                self.browser = self.playwright.chromium.launch_persistent_context(\n                    user_data_dir,\n                    executable_path=chrome_path,\n                    headless=headless,\n                    args=launch_args,\n                    channel=None,\n                    user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                    viewport={'width': 1920, 'height': 1080},\n                    locale='en-US',\n                    timezone_id='America/New_York',\n                    permissions=['geolocation'],\n                    extra_http_headers={\n                        'Accept-Language': 'en-US,en;q=0.9',\n                        'Accept-Encoding': 'gzip, deflate, br',\n                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                        'Sec-Fetch-Dest': 'document',\n                        'Sec-Fetch-Mode': 'navigate',\n                        'Sec-Fetch-Site': 'none',\n                        'Sec-Fetch-User': '?1',\n                        'Upgrade-Insecure-Requests': '1'\n                    }\n                )\n                self.context = self.browser\n                logger.info('âœ“ Using persistent context - login will be saved!')\n            else:\n                logger.info('Using Playwright bundled Chromium')\n                self.browser = self.playwright.chromium.launch_persistent_context(\n                    user_data_dir,\n                    headless=headless,\n                    args=launch_args,\n                    user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                    viewport={'width': 1920, 'height': 1080},\n                    locale='en-US',\n                    timezone_id='America/New_York',\n                    permissions=['geolocation'],\n                    extra_http_headers={\n                        'Accept-Language': 'en-US,en;q=0.9',\n                        'Accept-Encoding': 'gzip, deflate, br',\n                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                        'Sec-Fetch-Dest': 'document',\n                        'Sec-Fetch-Mode': 'navigate',\n                        'Sec-Fetch-Site': 'none',\n                        'Sec-Fetch-User': '?1',\n                        'Upgrade-Insecure-Requests': '1'\n                    }\n                )\n                self.context = self.browser\n                logger.info('âœ“ Using persistent context - login will be saved!')\n\n            anti_detection_script = \"\"\"\n                Object.defineProperty(navigator, 'webdriver', {get: () => undefined});\n                Object.defineProperty(navigator, 'plugins', {get: () => [1, 2, 3, 4, 5]});\n                Object.defineProperty(navigator, 'languages', {get: () => ['en-US', 'en']});\n                window.chrome = {runtime: {}};\n                Object.defineProperty(navigator, 'permissions', {get: () => ({query: () => Promise.resolve({state: 'granted'})})});\n            \"\"\"\n\n            if self.context:\n                for page in self.context.pages:\n                    page.add_init_script(script=anti_detection_script)\n\n            if self.context and len(self.context.pages) > 0:\n                self.page = self.context.pages[0]\n            elif self.context:\n                self.page = self.context.new_page()\n\n            # Set up dialog handler to prevent ProtocolError\n            if self.page:\n                def handle_dialog(dialog):\n                    \"\"\"Handle JavaScript dialogs gracefully.\"\"\"\n                    try:\n                        if dialog.type == 'beforeunload':\n                            # For beforeunload, we want to stay on page\n                            dialog.dismiss()\n                        else:\n                            # For other dialogs, accept them\n                            dialog.accept()\n                    except Exception as e:\n                        # If dialog handling fails (e.g., session closed), just log it\n                        logger.debug(f\"Dialog handling failed (may be expected): {e}\")\n\n                self.page.on(\"dialog\", handle_dialog)\n\n            if self.page is not None:\n                self.page.add_init_script(script=anti_detection_script)\n\n            if self.page is not None:\n                self.page.route(\"**/*\", lambda route: (\n                route.abort() if (\n\n                    '/ads/' in route.request.url or\n                    'doubleclick.net' in route.request.url or\n                    'googlesyndication' in route.request.url or\n\n                    (route.request.resource_type == \"image\" and int(route.request.headers.get('content-length', '0') or 0) > 100000) or\n                    route.request.resource_type == \"media\" or\n\n                    'analytics' in route.request.url or\n                    'pixel' in route.request.url\n                ) else route.continue_()\n            ))\n\n            logger.info('âœ“ Selective resource blocking enabled (faster load, Facebook still works)')\n            logger.info('Playwright browser setup successfully.')\n        except Exception as e:\n            logger.error(f'Failed to setup Playwright browser: {e}')\n            raise\n    def random_pause(self, min_time: float = 1, max_time: float = 5) -> None:\n\n        base_delay = random.uniform(min_time, max_time)\n\n        if random.random() < 0.15:\n            base_delay += random.uniform(0.1, 0.5)\n        time.sleep(base_delay)\n        logger.debug(f'Paused for {base_delay:.2f} seconds.')\n    def human_mouse_jiggle(self, element: Locator, moves: int = 2) -> None:\n\n        if not self.page:\n            return\n        try:\n\n            box: Optional[FloatRect] = element.bounding_box()\n            if box:\n\n                center_x = box['x'] + box['width'] / 2\n                center_y = box['y'] + box['height'] / 2\n                self.page.mouse.move(center_x, center_y)\n\n                for _ in range(moves):\n                    x_offset = random.randint(-15, 15)\n                    y_offset = random.randint(-15, 15)\n                    self.page.mouse.move(center_x + x_offset, center_y + y_offset)\n                    self.random_pause(0.3, 1)\n\n                self.page.mouse.move(center_x, center_y)\n                self.random_pause(0.3, 1)\n                logger.debug(f'Performed mouse jiggle with {moves} moves.')\n        except Exception as e:\n            logger.debug(f'Mouse jiggle failed: {e}')\n    def human_type(self, element: Locator, text: str) -> None:\n\n        element.click()\n        time.sleep(0.2)\n\n        words = text.split()\n        for w_i, word in enumerate(words):\n\n            if random.random() < 0.05:\n                fake_word = random.choice(['aaa', 'zzz', 'hmm'])\n                for c in fake_word:\n                    element.type(c, delay=random.uniform(80, 350))\n                for _ in fake_word:\n                    element.press('Backspace')\n                    time.sleep(random.uniform(0.06, 0.25))\n\n            for char in word:\n                if random.random() < 0.05:\n                    wrong_char = random.choice('abcdefghijklmnopqrstuvwxyz')\n                    element.type(wrong_char, delay=random.uniform(80, 350))\n                    time.sleep(random.uniform(0.06, 0.15))\n                    element.press('Backspace')\n                    time.sleep(random.uniform(0.06, 0.25))\n                element.type(char, delay=random.uniform(80, 350))\n\n            if w_i < len(words) - 1:\n                element.type(' ', delay=random.uniform(80, 300))\n\n            if random.random() < 0.03:\n                element.press('ArrowLeft')\n                time.sleep(random.uniform(0.1, 0.3))\n                element.press('ArrowRight')\n                time.sleep(random.uniform(0.1, 0.3))\n\n        self.random_pause(0.5, 1.5)\n        logger.debug('Completed human-like typing.')\n    def close_all_reply_boxes(self) -> None:\n        \"\"\"Close all open reply boxes to avoid confusion.\"\"\"\n        if not self.is_browser_alive() or not self.page:\n            logger.debug(\"Browser not alive, skipping close_all_reply_boxes\")\n            return\n\n        try:\n            logger.info('ðŸ”’ Closing any open reply boxes...')\n            # Use JavaScript to close all reply boxes\n            closed_count = self.page.evaluate(\"\"\"\n                (function() {\n                    let closed = 0;\n                    // Find all visible reply boxes\n                    const replyBoxes = document.querySelectorAll('p[dir=\"auto\"][class*=\"xdj266r\"], div[contenteditable=\"true\"]');\n\n                    for (const box of replyBoxes) {\n                        const style = window.getComputedStyle(box);\n                        if (style.display === 'none' || style.visibility === 'hidden') continue;\n\n                        // Check if this is a reply box (not main comment box)\n                        const ariaLabel = box.getAttribute('aria-label') || '';\n                        if (ariaLabel.toLowerCase().includes('write a comment')) continue;\n\n                        // Try to find and click cancel/close button\n                        let current = box;\n                        for (let i = 0; i < 5; i++) {\n                            current = current.parentElement;\n                            if (!current) break;\n\n                            // Look for close/cancel buttons\n                            const closeButtons = current.querySelectorAll('[role=\"button\"]');\n                            for (const btn of closeButtons) {\n                                const btnText = (btn.textContent || '').toLowerCase();\n                                if (btnText.includes('cancel') || btnText.includes('close') || btnText.includes('Ã—')) {\n                                    btn.click();\n                                    closed++;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    // Also press Escape to close any modals\n                    document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape', bubbles: true }));\n\n                    return closed;\n                })();\n            \"\"\")\n\n            # Also press Escape multiple times as fallback (only if browser is still alive)\n            if self.is_browser_alive() and self.page:\n                try:\n                    for _ in range(3):\n                        if self.is_browser_alive():\n                            self.page.keyboard.press('Escape')\n                            time.sleep(0.2)\n                        else:\n                            break\n                except Exception as e:\n                    if 'closed' not in str(e).lower():\n                        logger.debug(f\"Error pressing Escape: {e}\")\n\n            if closed_count > 0:\n                logger.info(f\"âœ… Closed {closed_count} reply boxes via JavaScript\")\n        except Exception as e:\n            error_msg = str(e)\n            if 'closed' in error_msg.lower() or 'Target' in error_msg:\n                logger.warning(f\"Browser closed during close_all_reply_boxes: {e}\")\n                # Don't raise, just return - caller should handle browser recovery\n            else:\n                logger.debug(f\"Error in close_all_reply_boxes: {e}\")\n            time.sleep(0.3)\n        except Exception as e:\n            logger.debug(f'Error closing reply boxes: {e}')\n    def random_scroll(self):\n\n        if not self.page:\n            return\n        scroll_direction = random.choice(['up', 'down'])\n        scroll_distance = random.randint(200, 800)\n\n        if random.random() < 0.3:\n\n            chunks = random.randint(2, 4)\n            chunk_size = scroll_distance // chunks\n            for i in range(chunks):\n                if scroll_direction == 'down':\n                    self.page.evaluate(f'window.scrollBy(0, {chunk_size})')\n                else:\n                    self.page.evaluate(f'window.scrollBy(0, -{chunk_size})')\n                time.sleep(random.uniform(0.2, 0.5))\n                logger.debug(f'Scrolling {scroll_direction} {chunk_size}px (chunk {i+1}/{chunks})')\n        else:\n            if scroll_direction == 'down':\n                self.page.evaluate(f'window.scrollBy(0, {scroll_distance})')\n                logger.debug(f'Scrolling down {scroll_distance} pixels.')\n            else:\n                self.page.evaluate(f'window.scrollBy(0, -{scroll_distance})')\n                logger.debug(f'Scrolling up {scroll_distance} pixels.')\n\n        self.random_pause(1, 3)\n\n    def simulate_human_activity(self):\n\n        if not self.page:\n            return\n        activity = random.choice(['scroll', 'mouse_move', 'pause', 'none'])\n\n        if activity == 'scroll':\n            logger.debug('Anti-detection: Performing random scroll')\n            self.random_scroll()\n\n        elif activity == 'mouse_move':\n            logger.debug('Anti-detection: Performing random mouse movement')\n            try:\n\n                x = random.randint(100, 1800)\n                y = random.randint(100, 900)\n                self.page.mouse.move(x, y)\n                time.sleep(random.uniform(0.1, 0.3))\n            except:\n                pass\n\n        elif activity == 'pause':\n            logger.debug('Anti-detection: Pausing (reading simulation)')\n            time.sleep(random.uniform(2, 5))\n\n    def parse_comment_timestamp(self, comment_element: Locator) -> Optional[datetime]:\n\n        try:\n\n            timestamp_selectors = [\n                \".//a[contains(@href, 'comment_id') or contains(@aria-label, 'ago')]\",\n                \".//span[contains(text(), 'h') or contains(text(), 'd') or contains(text(), 'w')]\",\n                \".//time\",\n                \".//*[contains(text(), 'minute') or contains(text(), 'hour') or contains(text(), 'day')]\"\n            ]\n\n            for selector in timestamp_selectors:\n                elements = comment_element.locator(selector).all()\n                for elem in elements:\n                    text = (elem.text_content() or '').strip()\n\n                    if self._parse_relative_time(text):\n                        return self._parse_relative_time(text)\n\n            return datetime.now()\n        except Exception as e:\n            logger.debug(f'Error parsing timestamp: {e}')\n            return datetime.now()\n\n    def _parse_relative_time(self, time_str: str) -> Optional[datetime]:\n\n        try:\n            import re\n            now = datetime.now()\n\n            pattern = r'(\\d+)\\s*([hHdDwWmM])'\n            match = re.search(pattern, time_str)\n\n            if match:\n                value = int(match.group(1))\n                unit = match.group(2).lower()\n\n                if unit in ['h']:\n                    return now - timedelta(hours=value)\n                elif unit in ['d']:\n                    return now - timedelta(days=value)\n                elif unit in ['w']:\n                    return now - timedelta(weeks=value)\n                elif unit in ['m'] and 'minute' in time_str.lower():\n                    return now - timedelta(minutes=value)\n\n            return None\n        except Exception:\n            return None\n\n    def classify_comment_type(self, comment_element: Locator, comment_text: str) -> str:\n\n        try:\n\n            parent_indicators = comment_element.locator(\".//*[contains(text(), 'Reply to') or contains(text(), 'replied')]\").all()\n            if parent_indicators:\n                return 'reply'\n\n            thread_indicators = comment_element.locator(\".//*[contains(text(), 'replies') or contains(text(), 'View more')]\").all()\n            if thread_indicators:\n                return 'thread'\n\n            return 'new'\n        except Exception as e:\n            logger.debug(f'Error classifying comment type: {e}')\n            return 'new'\n\n    def calculate_comment_priority(self, comment_data: CommentData) -> int:\n\n        priority = 100\n\n        try:\n\n            if comment_data['timestamp']:\n                hours_old = (datetime.now() - comment_data['timestamp']).total_seconds() / 3600\n                if hours_old < 1:\n                    priority += 50\n                elif hours_old < 6:\n                    priority += 30\n                elif hours_old < 24:\n                    priority += 15\n\n            text_length = len(comment_data['text'])\n            if text_length > 100:\n                priority += 20\n            elif text_length > 50:\n                priority += 10\n\n            if '?' in comment_data['text']:\n                priority += 25\n\n            if '@' in comment_data['text'] or '#' in comment_data['text']:\n                priority += 15\n\n            spam_indicators = ['buy now', 'click here', 'free money', 'www.', 'http']\n            for indicator in spam_indicators:\n                if indicator.lower() in comment_data['text'].lower():\n                    priority -= 30\n                    break\n\n            return max(priority, 10)\n\n        except Exception as e:\n            logger.debug(f'Error calculating priority: {e}')\n            return 100\n\n    def smart_comment_detection(self) -> list[CommentData]:\n\n        if not self.page:\n            return []\n\n        start_time = time.time()\n        detected_comments: list[CommentData] = []\n\n        try:\n            logger.info(\"ðŸ” Starting smart comment detection...\")\n\n            pre_expand_comments = self.get_comment_elements()\n            current_comment_count = len(pre_expand_comments)\n            count_changed = current_comment_count != self.last_comment_count\n\n            if count_changed:\n                logger.info(f\"ðŸ“ˆ Comment count changed: {self.last_comment_count} â†’ {current_comment_count}\")\n                self.last_comment_count = current_comment_count\n            else:\n                logger.debug(\"ðŸ“Š Comment count unchanged, forcing rescan to catch edits/live updates\")\n\n            self.smart_expand_comments()\n\n            comment_elements = self.get_comment_elements()\n            logger.info(f\"ðŸ” Found {len(comment_elements)} comment elements to analyze\")\n\n            for elem in comment_elements:\n                try:\n\n                    comment_id = self.get_comment_id(elem)\n\n                    # Check database first - use has_replied_to_comment for successful replies\n                    if self.db.has_replied_to_comment(comment_id):\n                        logger.debug(f\"ðŸ”„ Comment {comment_id[:8]} already replied to (successful), skipping\")\n                        continue\n\n                    # Also check if processed (includes failed attempts)\n                    if self.db.is_comment_processed(comment_id):\n                        processed_info = self.db.get_processed_comment(comment_id)\n                        if processed_info:\n                            status = processed_info.get('status', 'unknown')\n                            if status == 'success':\n                                logger.debug(f\"ðŸ”„ Comment {comment_id[:8]} already successfully replied to, skipping\")\n                                continue\n                            else:\n                                logger.debug(f\"ðŸ”„ Comment {comment_id[:8]} was processed but status was '{status}', will retry\")\n                        else:\n                            logger.debug(f\"ðŸ”„ Comment {comment_id[:8]} already processed in database, skipping\")\n                            continue\n\n                    if comment_id in self.session_processed_ids:\n                        logger.debug(f\"ðŸ”„ Comment {comment_id[:8]} already processed in this session, skipping\")\n                        continue\n\n                    element_html = elem.inner_html()[:100]\n                    element_signature = hashlib.sha256(element_html.encode()).hexdigest()[:16]\n                    user_id = self.get_user_id(elem)\n                    author = self.get_author_name(elem)\n                    comment_text = self.get_comment_text(elem)\n                    timestamp = self.parse_comment_timestamp(elem)\n\n                    logger.info(f\"ðŸ” Processing comment: ID={comment_id[:8]}, Author={author}, Text='{comment_text[:50]}...'\")\n\n                    # Early check for own comment - skip it immediately\n                    if self.is_own_comment(author, user_id):\n                        logger.debug(f\"ðŸš« Skipping own comment by {author} (user_id: {user_id[:8] if user_id else 'unknown'})\")\n                        # Store bot's user_id if we haven't found it yet\n                        if user_id and not self.bot_user_id:\n                            self.bot_user_id = user_id\n                            logger.info(f\"âœ… Detected bot's own user_id: {user_id[:8]}\")\n                        # Mark as processed so we don't check it again\n                        self.session_processed_ids.add(comment_id)\n                        self.db.add_processed_comment(\n                            comment_id,\n                            user_id,\n                            author if author is not None else '',\n                            comment_text,\n                            'SKIPPED_OWN_COMMENT',\n                            status='skipped',\n                            retry_count=0\n                        )\n                        continue\n\n                    if not comment_text or len(comment_text.strip()) < 2:\n                        logger.debug(f\"âš ï¸  Skipping comment with insufficient content: '{comment_text}'\")\n                        continue\n\n                    reply_button = self.find_reply_button_advanced(elem)\n\n                    if reply_button is None:\n                        reply_button = self.find_reply_button_fallback(elem)\n\n                    if reply_button is None:\n                        logger.debug(f\"âš ï¸  Trying final fallback for reply button detection for {author}\")\n                        try:\n\n                            all_buttons = elem.locator(\".//div[@role='button']\").all()\n                            if all_buttons:\n                                reply_button = all_buttons[-1]\n                                logger.debug(f\"âœ… Using fallback button for {author}\")\n                        except:\n                            pass\n\n                    if reply_button:\n                        logger.debug(f\"âœ… Found reply button for comment by {author}\")\n                    else:\n                        logger.debug(f\"âŒ No reply button found for comment by {author} - will still queue for processing\")\n\n                    comment_data: CommentData = {\n                        'id': comment_id,\n                        'user_id': user_id,\n                        'author': author,\n                        'text': comment_text,\n                        'element': elem,\n                        'reply_button': reply_button,\n                        'timestamp': timestamp,\n                        'priority': 100,\n                        'detected_at': datetime.now(),\n                        'comment_type': self.classify_comment_type(elem, comment_text)\n                    }\n\n                    comment_data['priority'] = self.calculate_comment_priority(comment_data)\n\n                    detected_comments.append(comment_data)\n                    self.known_comment_elements.add(element_signature)\n                    self.session_processed_ids.add(comment_id)\n\n                    logger.info(f\"âœ… Detected new comment by {author}: {comment_text[:50]}... (Priority: {comment_data['priority']})\")\n\n                except Exception as e:\n                    logger.debug(f\"âš ï¸  Error processing comment element: {e}\")\n                    continue\n\n            detected_comments.sort(key=lambda x: x['priority'], reverse=True)\n\n            scan_duration = time.time() - start_time\n            self.detection_metrics['total_scans'] += 1\n            self.detection_metrics['comments_detected'] += len(detected_comments)\n            self.detection_metrics['new_comments_found'] += len(detected_comments)\n            self.detection_metrics['last_scan_duration'] = scan_duration\n\n            if self.detection_metrics['total_scans'] > 0:\n                self.detection_metrics['processing_time_avg'] = (\n                    (self.detection_metrics['processing_time_avg'] * (self.detection_metrics['total_scans'] - 1) + scan_duration)\n                    / self.detection_metrics['total_scans']\n                )\n\n            logger.info(f\"ðŸŽ¯ Smart detection complete: {len(detected_comments)} new comments found in {scan_duration:.2f}s\")\n            self.last_full_scan = datetime.now()\n\n            return detected_comments\n\n        except Exception as e:\n            logger.error(f\"âŒ Error in smart comment detection: {e}\")\n            return []\n\n    def find_reply_button_advanced(self, comment_element: Locator) -> Locator | None:\n\n        try:\n            logger.debug(\"Starting advanced reply button detection...\")\n\n            logger.debug(\"Strategy 1: Direct text match for 'Reply'...\")\n            try:\n\n                reply_candidates = comment_element.locator(\"//*[text()='Reply' or text()='reply']\").all()\n                logger.debug(f\"  Found {len(reply_candidates)} elements with 'Reply' text\")\n\n                for candidate in reply_candidates:\n                    try:\n                        if candidate.is_visible():\n\n                            is_clickable = candidate.evaluate()\n\n                            if is_clickable:\n                                logger.debug(f\"Found clickable Reply element via text match\")\n                                return candidate\n                    except:\n                        continue\n            except Exception as e:\n                logger.debug(f\"  Strategy 1 error: {e}\")\n\n            logger.debug(\"Strategy 2: Clickable elements containing 'Reply'...\")\n            try:\n                all_elements = comment_element.locator(\".//*[contains(text(), 'Reply')]\").all()\n                logger.debug(f\"  Found {len(all_elements)} elements containing 'Reply'\")\n\n                for elem in all_elements:\n                    try:\n                        if elem.is_visible():\n                            text = (elem.text_content() or '').strip()\n\n                            if text.lower() in ['reply', 'reply ', ' reply'] or (len(text) < 15 and 'reply' in text.lower()):\n                                logger.debug(f\"Found potential reply button: '{text}'\")\n                                return elem\n                    except:\n                        continue\n            except Exception as e:\n                logger.debug(f\"  Strategy 2 error: {e}\")\n\n            logger.debug(\"Strategy 3: Traditional button role search...\")\n            try:\n                all_buttons = comment_element.locator(\".//*[@role='button']\").all()\n                logger.debug(f\"  Found {len(all_buttons)} elements with role=button\")\n\n                for btn in all_buttons:\n                    try:\n                        if btn.is_visible():\n                            text = (btn.text_content() or '').strip().lower()\n                            if 'reply' in text and len(text) < 30:\n                                logger.debug(f\"Found reply button via role=button: '{text}'\")\n                                return btn\n                    except:\n                        continue\n            except Exception as e:\n                logger.debug(f\"  Strategy 3 error: {e}\")\n\n            logger.debug(\"Strategy 4: Facebook clickable class search...\")\n            try:\n                clickable = comment_element.locator(\".//*[contains(@class, 'x1i10hfl')]\").all()\n                for elem in clickable:\n                    try:\n                        if elem.is_visible():\n                            text = (elem.text_content() or '').strip().lower()\n                            if text == 'reply' or (len(text) < 15 and 'reply' in text):\n                                logger.debug(f\"Found via clickable class: '{text}'\")\n                                return elem\n                    except:\n                        continue\n            except Exception as e:\n                logger.debug(f\"  Strategy 4 error: {e}\")\n\n            logger.debug(\"Advanced reply button detection failed\")\n            return None\n\n        except Exception as e:\n            logger.debug(f\"Error in advanced reply button detection: {e}\")\n            return None\n    def find_reply_button_fallback(self, comment_element: Locator) -> Locator | None:\n\n        try:\n            logger.debug(\"Using aggressive fallback reply button detection...\")\n\n            logger.debug(\"Strategy 1: Aggressive text search...\")\n            try:\n\n                all_reply_elements = comment_element.locator(\".//*\").all()\n\n                for elem in all_reply_elements:\n                    try:\n                        text = (elem.text_content() or '').strip()\n\n                        if text and text.lower() in ['reply', 'reply ', ' reply', 'reply...']:\n                            if elem.is_visible():\n                                logger.debug(f\"Found Reply text, attempting to use it: '{text}'\")\n                                return elem\n                    except:\n                        continue\n            except Exception as e:\n                logger.debug(f\"  Aggressive text search error: {e}\")\n\n            logger.debug(\"Strategy 2: Page-level Reply search...\")\n            try:\n                if self.page:\n\n                    page_reply_elements = self.page.locator(\"text='Reply'\").all()\n                    logger.debug(f\"  Found {len(page_reply_elements)} 'Reply' elements on page\")\n\n                    for elem in page_reply_elements:\n                        try:\n                            if elem.is_visible():\n\n                                logger.debug(\"Found visible Reply element on page\")\n                                return elem\n                        except:\n                            continue\n            except Exception as e:\n                logger.debug(f\"  Page-level search error: {e}\")\n\n            logger.debug(\"Strategy 3: Brute force clickability test...\")\n            try:\n\n                potential_buttons = comment_element.locator(\".//span, .//div\").all()\n\n                for elem in potential_buttons[:50]:\n                    try:\n                        if elem.is_visible():\n                            text = (elem.text_content() or '').strip().lower()\n\n                            if text == 'reply':\n                                logger.debug(\"Found element with exact 'reply' text\")\n                                return elem\n                    except:\n                        continue\n            except Exception as e:\n                logger.debug(f\"  Brute force error: {e}\")\n\n            logger.debug(\"All fallback strategies failed\")\n            return None\n\n        except Exception as e:\n            logger.debug(f\"Fallback detection error: {e}\")\n            return None\n\n    def get_comment_id(self, comment_element: Locator) -> str:\n\n        try:\n\n            html_content = comment_element.inner_html()[:200]\n            return hashlib.sha256(html_content.encode()).hexdigest()[:16]\n        except Exception:\n            return hashlib.sha256(str(time.time()).encode()).hexdigest()[:16]\n\n    def smart_expand_comments(self):\n            return None\n\n    def get_comment_id(self, comment_element: Locator) -> str:\n\n        try:\n\n            html_content = comment_element.inner_html()[:200]\n            return hashlib.sha256(html_content.encode()).hexdigest()[:16]\n        except Exception:\n            return 'new'\n\n    def smart_expand_comments(self):\n\n        if not self.page:\n            return\n\n        try:\n            logger.debug(\"ðŸ”„ Smart expanding comments...\")\n\n            try:\n                logger.debug(\"ðŸ“œ Scrolling to load more comments...\")\n                for _ in range(3):\n                    self.page.evaluate('window.scrollTo(0, document.body.scrollHeight)')\n                    time.sleep(0.5)\n\n                self.page.evaluate('window.scrollTo(0, 0)')\n                time.sleep(0.5)\n\n                self.page.evaluate('window.scrollTo(0, document.body.scrollHeight / 2)')\n                time.sleep(0.5)\n            except Exception as e:\n                logger.debug(f\"Error scrolling: {e}\")\n\n            expand_selectors = [\n                \"//div[@role='button'][contains(., 'View') and (contains(., 'more') or contains(., 'replies'))]\",\n                \"//div[@role='button'][contains(., 'replies')]\",\n                \"//span[contains(text(), 'View more')]/ancestor::div[@role='button']\",\n                \"//div[contains(@aria-label, 'View more')][@role='button']\",\n                \"//span[contains(text(), 'Hide') and contains(text(), 'replies')]/ancestor::div[@role='button']\",\n                \"//div[contains(text(), 'replies') and contains(text(), 'View')][@role='button']\"\n            ]\n\n            expanded_count = 0\n            for selector in expand_selectors:\n                try:\n                    buttons = self.page.locator(selector).all()\n                    for btn in buttons[:5]:\n                        if btn.is_visible():\n                            try:\n                                btn.scroll_into_view_if_needed()\n                                self.random_pause(0.2, 0.5)\n                                btn.click(timeout=2000)\n                                expanded_count += 1\n                                logger.debug(f\"âœ… Expanded comment section\")\n                                time.sleep(1)\n                            except:\n\n                                try:\n                                    btn.evaluate('el => el.click()')\n                                    expanded_count += 1\n                                    logger.debug(f\"âœ… Expanded comment section (JS click)\")\n                                except:\n                                    pass\n                except Exception:\n                    continue\n\n            if expanded_count > 0:\n                logger.debug(f\"ðŸ“– Expanded {expanded_count} comment sections\")\n                self.random_pause(1, 2)\n\n        except Exception as e:\n            logger.debug(f\"Error in smart expansion: {e}\")\n\n        if not self.page:\n            return\n        try:\n            logger.info('\" Expanding all comment threads (including sub-comments)...')\n\n            max_passes = 5\n            for pass_num in range(max_passes):\n                logger.debug(f'Expansion pass {pass_num + 1}/{max_passes}')\n\n                expand_selectors = [\n                    \"//span[contains(text(), 'View more')]\",\n                    \"//span[contains(text(), 'replies')]\",\n                    \"//span[contains(text(), 'more replies')]\",\n                    \"//span[contains(text(), 'Reply') and contains(text(), 'Â·')]\",\n                    \"//div[@role='button' and contains(., 'View')]\",\n                    \"//div[contains(@aria-label, 'View more')]\",\n                ]\n                buttons_found = 0\n                for selector in expand_selectors:\n                    try:\n                        expand_buttons: list[Locator] = self.page.locator(selector).all()\n                        for btn in expand_buttons:\n                            try:\n\n                                if not btn.is_visible():\n                                    continue\n                                btn.scroll_into_view_if_needed()\n                                self.random_pause(0.3, 0.8)\n\n                                try:\n                                    btn.click(timeout=2000)\n                                    buttons_found += 1\n                                    logger.debug(f\"Expanded comment thread\")\n                                except:\n\n                                    btn.evaluate('el => el.click()')\n                                    buttons_found += 1\n                                    logger.debug(f\"Expanded comment thread (JS)\")\n                                self.random_pause(0.5, 1.0)\n                            except Exception as e:\n                                logger.debug(f'Could not click expand button: {e}')\n                                continue\n                    except Exception as e:\n                        logger.debug(f'Error finding buttons with selector: {e}')\n                        continue\n                logger.info(f'Pass {pass_num + 1}: Expanded {buttons_found} comment threads')\n\n                if buttons_found == 0:\n                    logger.info(f\"All comment threads fully expanded after {pass_num + 1} passes\")\n                    break\n\n                self.page.evaluate('window.scrollBy(0, 500)')\n                self.random_pause(1, 2)\n            logger.info('\" Comment expansion complete - all threads visible')\n        except Exception as e:\n            logger.debug(f'Error expanding comments: {e}')\n\n    def get_comment_elements(self) -> list[Locator]:\n\n        if not self.page:\n            return []\n\n        selectors = [\n            \"//div[@role='article']\",\n            \"//div[contains(@data-testid, 'UFI2Comment/root_depth')]\",\n            \"//div[contains(@aria-label, 'Comment by')]\",\n            \"//div[@data-visualcompletion='ignore-dynamic' and .//div[@dir='auto']]\",\n            \"//div[contains(@class, 'x1n2onr6') and .//span[text()='Reply']]\",\n        ]\n\n        unique_comments: list[Locator] = []\n        seen_signatures: set[str] = set()\n\n        for selector in selectors:\n            try:\n                elements = self.page.locator(selector).all()\n                if not elements:\n                    continue\n\n                for elem in elements:\n                    try:\n                        text_preview = (elem.text_content() or '')[:120]\n                        data_ft = elem.get_attribute('data-ft') or ''\n                        signature_source = f\"{selector}|{text_preview}|{data_ft}\"\n                        signature = hashlib.sha256(signature_source.encode()).hexdigest()\n                        if signature in seen_signatures:\n                            continue\n                        seen_signatures.add(signature)\n                        unique_comments.append(elem)\n                    except Exception:\n                        unique_comments.append(elem)\n            except Exception as selector_error:\n                logger.debug(f\"Comment selector failed ({selector}): {selector_error}\")\n\n        logger.debug(f\"get_comment_elements gathered {len(unique_comments)} candidates\")\n        return unique_comments\n    def get_comment_id(self, comment_element: Locator) -> str:\n\n        try:\n            comment_text = (comment_element.text_content() or '')[:200]\n            author_elements = comment_element.locator(\".//a[contains(@href, '?id=') or contains(@class, 'actor')]\").all()\n            author = (author_elements[0].text_content() or '') if author_elements else 'unknown'\n\n            unique_string = f\"{author}_{comment_text}_{datetime.now().strftime('%Y-%m-%d')}\"\n            comment_id = hashlib.sha256(unique_string.encode()).hexdigest()[:16]\n            return comment_id\n        except Exception as e:\n            logger.debug(f'Error generating comment ID: {e}')\n            return hashlib.sha256(str(random.randint(1000000, 9999999)).encode()).hexdigest()[:16]\n    def get_user_id(self, comment_element: Locator) -> str:\n\n        try:\n            author_elements = comment_element.locator(\n                \".//a[contains(@href, 'user') or contains(@href, 'profile.php')]\"\n            ).all()\n            if author_elements:\n                href = author_elements[0].get_attribute('href') or ''\n\n                if 'user/' in href:\n                    user_id = href.split('user/')[-1].split('?')[0].split('/')[0]\n                elif 'id=' in href:\n                    user_id = href.split('id=')[-1].split('&')[0]\n                else:\n\n                    author_name = self.get_author_name(comment_element)\n                    user_id = hashlib.sha256((author_name or 'unknown').encode()).hexdigest()[:16]\n                return user_id\n\n            author_name = self.get_author_name(comment_element)\n            return hashlib.sha256((author_name or 'unknown').encode()).hexdigest()[:16]\n        except Exception as e:\n            logger.debug(f'Error getting user ID: {e}')\n            return hashlib.sha256(str(random.randint(1000000, 9999999)).encode()).hexdigest()[:16]\n    def get_author_name(self, comment_element: Locator) -> str | None:\n\n        try:\n\n            facebook_author_selectors = [\n                'span.x193iq5w[dir=\"auto\"]',\n                'span[dir=\"auto\"]',\n                'span.x193iq5w',\n            ]\n\n            for selector in facebook_author_selectors:\n                elements = comment_element.locator(selector).all()\n                for element in elements:\n                    text = (element.text_content() or '').strip()\n\n                    if (text and\n                        len(text) > 0 and\n                        len(text) < 100 and\n                        not any(x in text.lower() for x in [\n                            'like', 'reply', 'comment', 'share', 'edited', 'most relevant',\n                            'minute', 'hour', 'day', 'week', 'ago', 'just now',\n                            'see more', 'hide', 'translate'\n                        ]) and\n\n                        any(c.isalpha() for c in text)):\n                        logger.debug(f\"âœ… Found author name: '{text}' using Facebook selector: {selector}\")\n                        return text\n\n            legacy_selectors = [\n                \".//a[@role='link']//span\",\n                \".//a[contains(@href, 'user')]//span\",\n                \".//a[contains(@href, 'profile.php')]//span\",\n                \".//strong//a\",\n                \".//h3//a\",\n            ]\n\n            for selector in legacy_selectors:\n                elements = comment_element.locator(selector).all()\n                for element in elements:\n                    text = (element.text_content() or '').strip()\n                    if (text and len(text) > 0 and len(text) < 100 and\n                        text not in ['Author', 'Admin', 'Like', 'Reply', 'Comment', 'Share', 'Edited', 'Most relevant']):\n                        logger.debug(f\"âœ… Found author name: '{text}' using legacy selector: {selector}\")\n                        return text\n\n            strong_elements = comment_element.locator(\".//strong, .//b, .//em\").all()\n            for element in strong_elements:\n                text = (element.text_content() or '').strip()\n                if (text and len(text) > 0 and len(text) < 50 and\n                    not any(x in text.lower() for x in ['like', 'reply', 'comment', 'minute', 'hour', 'day', 'week', 'ago'])):\n                    logger.debug(f\"âœ… Found author name in strong element: '{text}'\")\n                    return text\n\n            full_text = (comment_element.text_content() or '').strip()\n            if full_text:\n                lines = [line.strip() for line in full_text.split('\\n') if line.strip()]\n                if lines:\n                    first_line = lines[0]\n\n                    if (len(first_line) > 0 and len(first_line) < 50 and\n                        not any(x in first_line.lower() for x in ['like', 'reply', 'comment', 'minute', 'hour', 'day', 'week'])):\n                        logger.debug(f\"âœ… Found author name from first line: '{first_line}'\")\n                        return first_line\n\n            logger.debug(\"âš ï¸  Could not extract author name from comment element\")\n            return \"Unknown User\"\n\n        except Exception as e:\n            logger.debug(f'Error getting author name: {e}')\n            return \"Unknown User\"\n    def get_post_content(self) -> str:\n        \"\"\"Extract the main post content from the Facebook post page.\"\"\"\n        if not self.page:\n            return \"\"\n\n        # Return cached content if available (including empty string to avoid re-extraction)\n        if self.post_content_cache is not None:\n            return self.post_content_cache\n\n        try:\n            logger.info(\"ðŸ“„ Extracting post content...\")\n\n            # Try multiple selectors to find the main post content\n            post_selectors = [\n                # Main post content area\n                \"//div[@role='article']//div[@dir='auto']\",\n                \"//div[contains(@data-pagelet, 'FeedUnit')]//div[@dir='auto']\",\n                \"//div[@role='article']//span[@dir='auto']\",\n                # Post text in various structures\n                \"//div[@role='article']//div[contains(@class, 'x193iq5w')]//span[@dir='auto']\",\n                \"//div[@role='article']//p[@dir='auto']\",\n                # Fallback: get text from the main article\n                \"//div[@role='article']\",\n            ]\n\n            post_text = \"\"\n            for selector in post_selectors:\n                try:\n                    elements = self.page.locator(selector).all()\n                    if elements:\n                        # Get the first element which is usually the main post\n                        main_element = elements[0]\n                        text = (main_element.text_content() or '').strip()\n\n                        # Filter out common UI elements\n                        if (text and\n                            len(text) > 20 and  # Must be substantial\n                            len(text) < 5000 and  # Not too long\n                            'like' not in text.lower()[:50] and\n                            'comment' not in text.lower()[:50] and\n                            'share' not in text.lower()[:50] and\n                            not any(time_word in text.lower()[:100] for time_word in ['minute', 'hour', 'day', 'week', 'ago', 'just now'])):\n\n                            # Clean up the text\n                            lines = [line.strip() for line in text.split('\\n') if line.strip()]\n                            # Filter out lines that look like UI elements\n                            filtered_lines = []\n                            for line in lines:\n                                if (len(line) > 5 and\n                                    not any(ui_word in line.lower() for ui_word in ['like', 'comment', 'share', 'reply', 'see more', 'see less']) and\n                                    not any(time_word in line.lower() for time_word in ['minute', 'hour', 'day', 'week', 'ago'])):\n                                    filtered_lines.append(line)\n\n                            if filtered_lines:\n                                post_text = '\\n'.join(filtered_lines[:10])  # Take first 10 meaningful lines\n                                break\n                except Exception as e:\n                    logger.debug(f\"Selector {selector} failed: {e}\")\n                    continue\n\n            # If we didn't find it with selectors, try getting from the main article\n            if not post_text or len(post_text) < 20:\n                try:\n                    article = self.page.locator(\"//div[@role='article']\").first\n                    if article.count() > 0 and article.is_visible():\n                        full_text = (article.text_content() or '').strip()\n                        # Extract the main content (usually the first substantial paragraph)\n                        paragraphs = [p.strip() for p in full_text.split('\\n') if len(p.strip()) > 20]\n                        if paragraphs:\n                            # The first substantial paragraph is usually the post\n                            post_text = paragraphs[0]\n                except Exception as e:\n                    logger.debug(f\"Fallback post extraction failed: {e}\")\n\n            # Clean and limit the post content\n            if post_text:\n                post_text = post_text.strip()[:1000]  # Limit to 1000 chars\n                self.post_content_cache = post_text\n                logger.info(f\"âœ… Extracted post content ({len(post_text)} chars): {post_text[:100]}...\")\n            else:\n                logger.warning(\"âš ï¸  Could not extract post content\")\n                post_text = \"\"\n                # Cache empty string to avoid repeated extraction attempts\n                self.post_content_cache = \"\"\n\n            return post_text\n\n        except Exception as e:\n            logger.error(f\"Error extracting post content: {e}\")\n            return \"\"\n\n    def get_comment_text(self, comment_element: Locator) -> str:\n\n        try:\n\n            text_divs = comment_element.locator('div[dir=\"auto\"]').all()\n\n            logger.debug(f\"Found {len(text_divs)} div[dir='auto'] elements\")\n\n            if text_divs:\n                for idx, div in enumerate(text_divs):\n                    text = (div.text_content() or '').strip()\n                    logger.debug(f\"  Div {idx+1}: '{text[:50]}...' (len={len(text)})\")\n\n                    if text and len(text) > 0 and text not in ['Like', 'Reply', 'Author', 'Comment', 'Share']:\n\n                        if not any(pattern in text for pattern in ['5h', '1h', '2h', '3h', '4h', '6h', '7h', '8h', '9h',\n                                                                   '1d', '2d', '3d', '4d', '5d', '6d', '7d',\n                                                                   '1w', '2w', '3w', '4w', 'minute', 'hour', 'day', 'week']):\n                            logger.info(f\"âœ“ Found comment text: '{text[:50]}'\")\n                            return text\n\n            full_text = comment_element.text_content() or ''\n            lines = [line.strip() for line in full_text.split('\\n') if line.strip()]\n\n            author_found = False\n            for line in lines:\n\n                if len(line) < 1:\n                    continue\n\n                if line in ['Like', 'Reply', 'Comment', 'Share', 'Author', 'Admin', 'Edited', 'Most relevant']:\n                    continue\n\n                if any(x in line for x in ['5h', '1h', '2h', '3h', '4h', '6h', '7h', '8h', '9h',\n                                           '1d', '2d', '3d', '4d', '5d', '6d', '7d',\n                                           '1w', '2w', '3w', '4w', 'minute', 'hour', 'day', 'week', 'ago']):\n                    continue\n\n                if 'edit' in line.lower() or 'delete' in line.lower():\n                    continue\n\n                if author_found:\n                    logger.debug(f\"Found comment text (fallback): {line[:50]}\")\n                    return line\n                else:\n                    author_found = True\n\n            logger.warning(\"Could not extract comment text from element\")\n            return \"\"\n\n        except Exception as e:\n            logger.error(f'Error extracting comment text: {e}')\n            import traceback\n            logger.error(traceback.format_exc())\n            return \"\"\n\n    def add_comments_to_queue(self, comments: list[CommentData]) -> None:\n\n        if not comments:\n            logger.debug(\"No comments provided to add_comments_to_queue\")\n            return\n\n        logger.info(f\"ðŸ“‹ Processing {len(comments)} detected comments for queue...\")\n\n        valid_comments = []\n        seen_comment_ids = set()\n        seen_user_ids = set()\n\n        for comment in comments:\n            comment_id = comment.get('id', '')\n            user_id = comment.get('user_id', '')\n            author = comment.get('author')\n\n            # Skip if comment_id is already in queue or processed\n            if comment_id and self.is_comment_id_in_queue(comment_id):\n                logger.debug(f\"ðŸ”„ Skipping duplicate comment_id: {comment_id[:8]}\")\n                continue\n\n            # Skip if we've already seen this comment_id in this batch\n            if comment_id in seen_comment_ids:\n                logger.debug(f\"ðŸ”„ Skipping duplicate comment_id in batch: {comment_id[:8]}\")\n                continue\n            seen_comment_ids.add(comment_id)\n\n            # Check if it's the bot's own comment (improved check)\n            if self.is_own_comment(author, user_id):\n                logger.info(f\"ðŸš« Skipping own comment by {author} (user_id: {user_id[:8] if user_id else 'unknown'})\")\n                # Store bot's user_id if we haven't found it yet\n                if user_id and not self.bot_user_id:\n                    self.bot_user_id = user_id\n                    logger.info(f\"âœ… Detected bot's own user_id: {user_id[:8]}\")\n                continue\n\n            if not comment['text'] or len(comment['text'].strip()) < 2:\n                logger.debug(f\"ðŸš« Skipping comment with no text by {author}\")\n                continue\n\n            # Check if user is already in queue (prevent multiple comments from same user)\n            if user_id and self.is_user_in_queue(user_id):\n                logger.info(f\"ðŸš« Skipping comment by {author}: user already in queue (user_id: {user_id[:8]})\")\n                continue\n\n            # Check if we've already seen this user_id in this batch\n            if user_id in seen_user_ids:\n                logger.info(f\"ðŸš« Skipping duplicate user in batch: {author} (user_id: {user_id[:8]})\")\n                continue\n            seen_user_ids.add(user_id)\n\n            try:\n                can_reply, reason = self.can_reply_to_user(\n                    user_id,\n                    author if author is not None else ''\n                )\n                if not can_reply:\n                    logger.info(f\"ðŸš« Skipping comment by {author}: {reason}\")\n                    continue\n            except Exception as e:\n\n                logger.warning(f\"âš ï¸  User check failed for {author}, allowing anyway: {e}\")\n\n            valid_comments.append(comment)\n            logger.info(f\"âœ… Added comment by {author} to processing queue: '{comment['text'][:50]}...'\")\n\n        if valid_comments:\n            self.comment_queue['pending'].extend(valid_comments)\n\n            self.comment_queue['pending'].sort(key=lambda x: x['priority'], reverse=True)\n\n            max_queue_size = 50\n            if len(self.comment_queue['pending']) > max_queue_size:\n                self.comment_queue['pending'] = self.comment_queue['pending'][:max_queue_size]\n\n            logger.info(f\"ðŸ“¥ Added {len(valid_comments)} comments to queue (Total pending: {len(self.comment_queue['pending'])})\")\n        else:\n            logger.warning(f\"âš ï¸  No valid comments to add to queue from {len(comments)} detected comments\")\n\n    def process_comment_queue(self) -> bool:\n\n        if not self.comment_queue['pending']:\n            logger.debug(\"ðŸ” No comments in pending queue to process\")\n            return False\n\n        logger.info(f\"ðŸ“‹ Processing {len(self.comment_queue['pending'])} comments from queue\")\n\n        processed_any = False\n\n        batch_size = len(self.comment_queue['pending'])\n\n        if batch_size == 0:\n            return False\n\n        logger.info(f\"ðŸ”„ Starting to process {batch_size} comments from queue...\")\n\n        for batch_num in range(batch_size):\n\n            try:\n                rate_ok, rate_msg = self.check_rate_limit()\n                if not rate_ok:\n                    logger.warning(f\"ðŸš« Rate limit reached: {rate_msg}\")\n\n                    logger.info(\"âš ï¸  Continuing in offline mode (rate limit check failed)\")\n            except Exception as e:\n\n                logger.debug(f\"Rate limit check failed (offline mode), continuing: {e}\")\n\n            if not self.comment_queue['pending']:\n                break\n\n            comment = self.comment_queue['pending'].pop(0)\n            self.comment_queue['processing'].append(comment)\n\n            logger.info(f\"\\nðŸš€ Processing high-priority comment {batch_num + 1}/{batch_size} (Priority: {comment['priority']})\")\n            logger.info(f\"ðŸ‘¤ Author: {comment['author']}\")\n            logger.info(f\"ðŸ“ Text: {comment['text'][:100]}...\")\n            logger.info(f\"â° Detected: {comment['detected_at'].strftime('%H:%M:%S')}\")\n            logger.info(f\"ðŸ”˜ Has reply button: {'Yes' if comment['reply_button'] else 'No (will retry)'}\")\n\n            success = self.reply_to_comment(comment, len(self.comment_queue['completed']) + 1)\n\n            self.comment_queue['processing'].remove(comment)\n\n            if success:\n                self.comment_queue['completed'].append(comment['id'])\n                processed_any = True\n                self.last_activity_time = datetime.now()\n                logger.info(f\"âœ… Successfully processed comment {comment['id'][:8]}\")\n            else:\n                self.comment_queue['failed'].append(comment['id'])\n                logger.warning(f\"âŒ Failed to process comment {comment['id'][:8]}\")\n\n            if batch_num < batch_size - 1:\n                self.random_pause(1, 3)\n\n        return processed_any\n\n    def adaptive_delay_between_comments(self) -> None:\n\n        base_delay = random.uniform(\n            float(self.config['DELAYS']['MEDIUM_MIN']),\n            float(self.config['DELAYS']['MEDIUM_MAX'])\n        )\n\n        queue_size = len(self.comment_queue['pending'])\n        if queue_size > 10:\n            base_delay *= 0.7\n        elif queue_size < 3:\n            base_delay *= 1.3\n\n        total_attempts = len(self.comment_queue['completed']) + len(self.comment_queue['failed'])\n        if total_attempts > 5:\n            success_rate = len(self.comment_queue['completed']) / total_attempts\n            if success_rate < 0.7:\n                base_delay *= 1.5\n\n        final_delay = base_delay + random.uniform(-0.5, 0.5)\n        final_delay = max(1.0, final_delay)\n\n        logger.debug(f\"â±ï¸  Adaptive delay: {final_delay:.1f}s (base: {base_delay:.1f}s)\")\n        time.sleep(final_delay)\n\n    def update_adaptive_scan_interval(self) -> None:\n\n        base_interval = float(self.config['DELAYS']['SCAN_INTERVAL'])\n\n        time_since_last_activity = (datetime.now() - self.last_activity_time).total_seconds()\n\n        if len(self.comment_queue['pending']) == 0:\n            if time_since_last_activity < 300:\n                self.adaptive_scan_interval = base_interval * 0.5\n            else:\n                self.adaptive_scan_interval = base_interval * 1.5\n        else:\n            self.adaptive_scan_interval = base_interval * 0.8\n\n        self.adaptive_scan_interval = max(5.0, min(60.0, self.adaptive_scan_interval))\n\n        logger.debug(f\"ðŸ“Š Adaptive scan interval: {self.adaptive_scan_interval:.1f}s\")\n\n    def print_queue_status(self) -> None:\n\n        pending = len(self.comment_queue['pending'])\n        processing = len(self.comment_queue['processing'])\n        completed = len(self.comment_queue['completed'])\n        failed = len(self.comment_queue['failed'])\n\n        logger.info(f\"\\nðŸ“Š QUEUE STATUS\")\n        logger.info(f\"{'='*50}\")\n        logger.info(f\"ðŸ“¥ Pending: {pending}\")\n        logger.info(f\"âš™ï¸  Processing: {processing}\")\n        logger.info(f\"âœ… Completed: {completed}\")\n        logger.info(f\"âŒ Failed: {failed}\")\n\n        if pending > 0:\n\n            logger.info(f\"\\nðŸ”œ Next in queue:\")\n            for i, comment in enumerate(self.comment_queue['pending'][:3]):\n                logger.info(f\"   {i+1}. {comment['author']} (Priority: {comment['priority']})\")\n\n        logger.info(f\"\\nâš¡ PERFORMANCE METRICS\")\n        logger.info(f\"{'='*50}\")\n        logger.info(f\"ðŸ” Total scans: {self.detection_metrics['total_scans']}\")\n        logger.info(f\"ðŸ“ˆ Comments detected: {self.detection_metrics['comments_detected']}\")\n        logger.info(f\"â±ï¸  Avg scan time: {self.detection_metrics['processing_time_avg']:.2f}s\")\n        logger.info(f\"ðŸŽ¯ Detection rate: {self.detection_metrics['new_comments_found']/max(1, self.detection_metrics['total_scans']):.1f}/scan\")\n        logger.info(f\"â° Adaptive interval: {self.adaptive_scan_interval:.1f}s\")\n        logger.info(f\"{'='*50}\\n\")\n\n    def get_all_comments(self) -> list[CommentData]:\n\n        if not self.page:\n            return []\n        self.smart_expand_comments()\n        comments: list[CommentData] = []\n        try:\n            for _ in range(3):\n                self.page.evaluate('window.scrollTo(0, document.body.scrollHeight)')\n                self.random_pause(2, 4)\n            comment_elements: list[Locator] = self.page.locator(\"//div[@role='article']\").all()\n            logger.info(f'Found {len(comment_elements)} comment elements.')\n            for elem in comment_elements:\n                try:\n                    comment_id = self.get_comment_id(elem)\n                    user_id = self.get_user_id(elem)\n                    author = self.get_author_name(elem)\n\n                    comment_text = self.get_comment_text(elem)\n\n                    if not comment_text or len(comment_text) < 1:\n                        logger.debug(f\"Skipping comment with no text content\")\n                        continue\n\n                    reply_buttons: list[Locator] = elem.locator(\"//div[@role='button' and contains(@class, 'x1i10hfl') and (contains(text(), 'Reply') or contains(text(), 'reply'))]\").all()\n\n                    if not reply_buttons:\n                        reply_buttons: list[Locator] = elem.locator(\".//div[@role='button']\").all()\n\n                    reply_button = None\n                    for btn in reply_buttons:\n                        btn_text = (btn.text_content() or '').lower()\n                        if 'reply' in btn_text or 'Ø±Ø¯' in btn_text or 'rÃ©pondre' in btn_text:\n                            reply_button = btn\n                            break\n\n                    comment_data: CommentData = {\n                        'id': comment_id,\n                        'user_id': user_id,\n                        'author': author,\n                        'text': comment_text[:200],\n                        'element': elem,\n                        'reply_button': reply_button,\n                        'timestamp': self.parse_comment_timestamp(elem),\n                        'priority': 100,\n                        'detected_at': datetime.now(),\n                        'comment_type': self.classify_comment_type(elem, comment_text)\n                    }\n                    comments.append(comment_data)\n                    logger.debug(f\"Added comment from {author}: {comment_text[:50]}\")\n\n                except Exception as e:\n                    logger.debug(f'Error processing comment element: {e}')\n                    continue\n            logger.info(f'Processed {len(comments)} comments.')\n            return comments\n        except Exception as e:\n            logger.error(f'Error getting comments: {e}')\n            return []\n    def check_rate_limit(self) -> Tuple[bool, str]:\n\n        window = int(self.config.get('RATE_LIMIT_WINDOW', 300))\n        recent_count = self.db.get_recent_reply_count(window)\n        if recent_count >= int(self.config.get('MAX_REPLIES_PER_WINDOW', 8)):\n            reason = f\"Rate limit exceeded: {recent_count}/{int(self.config.get('MAX_REPLIES_PER_WINDOW', 8))} replies in last {window}s\"\n            logger.warning(reason)\n            return False, reason\n        return True, ''\n    def can_reply_to_user(self, user_id: str, user_name: str) -> Tuple[bool, str]:\n\n        try:\n            reply_count = self.db.get_user_reply_count(user_id)\n            max_replies = int(self.config.get('MAX_REPLIES_PER_USER', 9999))\n            if reply_count >= max_replies:\n                reason = f'Already replied to {user_name} {reply_count} time(s)'\n                return False, reason\n        except Exception as e:\n\n            logger.debug(f\"User reply count check failed (offline), allowing: {e}\")\n\n        cooldown_seconds = int(self.config.get('COOLDOWN_SECONDS', 0))\n        if cooldown_seconds > 0:\n            try:\n                last_reply = self.db.get_last_reply_time(user_id)\n                if last_reply:\n                    time_since_last = datetime.now() - last_reply\n                    cooldown = timedelta(seconds=cooldown_seconds)\n                    if time_since_last < cooldown:\n                        remaining = (cooldown - time_since_last).seconds\n                        reason = f'Cooldown active for {user_name}: {remaining}s remaining'\n                        return False, reason\n            except Exception as e:\n\n                logger.debug(f\"Cooldown check failed (offline), allowing: {e}\")\n\n        return True, ''\n    def generate_reply(self, comment_text: str, post_content: str | None = None) -> str:\n        try:\n            # Validate and sanitize input\n            if not comment_text or len(comment_text.strip()) < 2:\n                logger.warning(\"Comment text too short, using fallback\")\n                return \"Thanks for your comment!\"\n\n            comment_clean = sanitize_text(comment_text, max_length=500)\n\n            # Get post content if not provided\n            if post_content is None:\n                post_content = self.get_post_content()\n            else:\n                post_content = sanitize_text(post_content, max_length=500)\n\n            # Create cache key including both post and comment for better context\n            cache_input = f\"{post_content[:200]}|{comment_clean}\"\n            cache_key = hashlib.sha256(cache_input.encode()).hexdigest()[:16]\n\n            # Check cache\n            if cache_key in self.response_cache:\n                cached = self.response_cache[cache_key]\n                logger.debug(f'Using cached response for similar comment')\n                return cached\n\n            # Clean cache if too large\n            if len(self.response_cache) > MAX_CACHE_SIZE:\n                keys_to_remove = list(self.response_cache.keys())[:CACHE_CLEANUP_SIZE]\n                for key in keys_to_remove:\n                    del self.response_cache[key]\n                logger.debug(f\"Cleaned {CACHE_CLEANUP_SIZE} entries from response cache\")\n\n            # Build prompt with both post and comment context\n            if post_content and len(post_content.strip()) > 10:\n                # Use templates that support both post and comment (first 5 templates)\n                template = random.choice(PROMPT_TEMPLATES[:5])\n                try:\n                    prompt = template.format(\n                        post=post_content[:500],  # Limit post content to 500 chars\n                        comment=comment_clean\n                    )\n                    logger.debug(f\"Using post+comment context (post: {len(post_content)} chars, comment: {len(comment_clean)} chars)\")\n                except (KeyError, IndexError, ValueError) as e:\n                    # Fallback if template doesn't have {post} or wrong template selected\n                    logger.warning(f\"Template error, using comment-only: {e}\")\n                    try:\n                        template = random.choice(PROMPT_TEMPLATES[5:])\n                        prompt = template.format(comment=comment_clean)\n                    except (IndexError, ValueError) as fallback_error:\n                        # Ultimate fallback if slicing fails\n                        logger.error(f\"Fallback template selection failed: {fallback_error}\")\n                        prompt = f\"Generate a helpful reply to this comment: {comment_clean}\"\n            else:\n                # Fallback to comment-only if post content not available (last 5 templates)\n                try:\n                    template = random.choice(PROMPT_TEMPLATES[5:])\n                    prompt = template.format(comment=comment_clean)\n                    logger.debug(f\"Using comment-only context (post not available)\")\n                except (IndexError, ValueError) as e:\n                    # Ultimate fallback if slicing fails\n                    logger.error(f\"Template selection failed: {e}\")\n                    prompt = f\"Generate a helpful reply to this comment: {comment_clean}\"\n\n            system_prompt = \"You are a helpful assistant replying to Facebook comments. Generate brief, relevant replies that directly address the comment content in the context of the original post. Be friendly and conversational. Do not use emojis unless absolutely necessary. Keep replies under 100 words.\"\n\n            seed = random.randint(1, 10000)\n\n            # Get OpenAI config\n            openai_config = get_openai_config()\n\n            response = self.openai_client.chat.completions.create(\n                model=openai_config['MODEL'],\n                messages=[\n                    {'role': 'system', 'content': system_prompt},\n                    {'role': 'user', 'content': prompt}\n                ],\n                temperature=openai_config['TEMPERATURE'],\n                max_tokens=openai_config['MAX_TOKENS'],\n                seed=seed\n            )\n\n            try:\n                reply_raw = getattr(response.choices[0].message, 'content', '')\n                reply = (reply_raw or '').strip()\n\n                if not reply or len(reply) < 3:\n                    reply = f\"Thanks for your comment about {comment_clean[:30]}...\"\n\n            except Exception as e:\n                logger.warning(f'Error extracting reply: {e}')\n                reply = f\"Thanks for your comment about {comment_clean[:30]}...\"\n\n            if reply:\n                self.response_cache[cache_key] = reply\n\n            # Cache cleanup is now handled earlier in the function\n\n            logger.info(f'Generated reply for comment \"{comment_clean[:50]}...\": {reply[:50]}...')\n            return reply\n        except Exception as e:\n            logger.error(f'Failed to generate reply: {e}')\n\n            fallbacks = [\n                'Thank you for your comment! I appreciate your input.',\n                'Thanks for sharing your thoughts!',\n                'I appreciate you taking the time to comment!',\n                'Great point! Thanks for your feedback.',\n                'Thank you! Your input is valuable.'\n            ]\n            return random.choice(fallbacks)\n    def verify_reply_box_belongs_to_comment(self, reply_box: Locator, comment_element: Locator) -> bool:\n        \"\"\"Verify that the reply box actually belongs to the comment we're replying to.\"\"\"\n        try:\n            comment_bbox = comment_element.bounding_box()\n            reply_bbox = reply_box.bounding_box()\n\n            if not comment_bbox or not reply_bbox:\n                return False\n\n            # Check if reply box is within reasonable distance of comment\n            comment_bottom = comment_bbox.get('y', 0) + comment_bbox.get('height', 0)\n            reply_top = reply_bbox.get('y', 0)\n\n            # Reply box should be below the comment, within 500px\n            distance = reply_top - comment_bottom\n            if distance < 0 or distance > 500:\n                logger.warning(f\"Reply box too far from comment (distance: {distance:.0f}px)\")\n                return False\n\n            # Check if reply box is within the same article/comment thread\n            try:\n                # Get the comment's article container\n                comment_article = comment_element.locator('xpath=./ancestor::div[contains(@role, \"article\")]').first\n                if comment_article.count() > 0:\n                    # Check if reply box is within the same article\n                    reply_in_article = reply_box.locator('xpath=./ancestor::div[contains(@role, \"article\")]').first\n                    if reply_in_article.count() > 0:\n                        # Verify they're the same article by checking if reply box is descendant of comment article\n                        article_id = comment_article.evaluate('el => el.getAttribute(\"data-pagelet\") || el.id || \"\"')\n                        reply_article_id = reply_in_article.evaluate('el => el.getAttribute(\"data-pagelet\") || el.id || \"\"')\n                        if article_id and reply_article_id and article_id == reply_article_id:\n                            return True\n\n                        # Alternative: check if reply box is a descendant of comment article\n                        reply_is_descendant = reply_box.evaluate(f\"\"\"\n                            (function() {{\n                                const commentArticle = document.evaluate('{comment_article}', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n                                const replyBox = arguments[0];\n                                if (!commentArticle || !replyBox) return false;\n                                return commentArticle.contains(replyBox);\n                            }})();\n                        \"\"\")\n                        if reply_is_descendant:\n                            return True\n            except Exception as e:\n                logger.debug(f\"Article verification failed: {e}\")\n\n            # Check if there's a \"Reply to [author]\" text near the reply box\n            try:\n                reply_container = reply_box.locator('xpath=./ancestor::div[position() <= 5]').first\n                if reply_container.count() > 0:\n                    container_text = (reply_container.text_content() or '').lower()\n                    # Get comment author name\n                    comment_author = self.get_author_name(comment_element)\n                    if comment_author:\n                        author_lower = comment_author.lower()\n                        # Check if container mentions replying to this author\n                        if f'reply to {author_lower}' in container_text or f'replying to {author_lower}' in container_text:\n                            return True\n            except Exception as e:\n                logger.debug(f\"Author verification failed: {e}\")\n\n            # If distance is reasonable, accept it\n            if 0 <= distance <= 300:\n                return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Reply box verification error: {e}\")\n            return False\n\n    def find_reply_input_box(self, comment_element: Locator) -> Locator | None:\n        if not self.page:\n            return None\n\n        # Get comment info for logging\n        try:\n            comment_author = self.get_author_name(comment_element)\n            comment_text = self.get_comment_text(comment_element)\n            comment_id = self.get_comment_id(comment_element)\n            logger.info(f\"ðŸ” Looking for reply box for comment by {comment_author} (ID: {comment_id[:8]}): '{comment_text[:50]}...'\")\n        except:\n            pass\n\n        # First, try to find the reply box marked by JavaScript\n        try:\n            marked_box = self.page.locator('[data-bot-selected-reply-box=\"true\"]').first\n            if marked_box.count() > 0 and marked_box.is_visible():\n                logger.info('âœ… Found JavaScript-marked reply box')\n                # Verify it belongs to this comment\n                if self.verify_reply_box_belongs_to_comment(marked_box, comment_element):\n                    # Remove the marker\n                    marked_box.evaluate('el => el.removeAttribute(\"data-bot-selected-reply-box\")')\n                    return marked_box\n                else:\n                    # Remove invalid marker\n                    marked_box.evaluate('el => el.removeAttribute(\"data-bot-selected-reply-box\")')\n        except Exception as e:\n            logger.debug(f\"JavaScript-marked box check failed: {e}\")\n\n        max_attempts = 5\n        for attempt in range(max_attempts):\n            time.sleep(0.5)\n            try:\n                comment_bbox: Optional[FloatRect] = comment_element.bounding_box()\n                if not comment_bbox:\n                    logger.warning('Could not get comment bounding box')\n                    continue\n\n                logger.info(f'Looking for reply box near comment at y={comment_bbox.get(\"y\", 0):.0f}')\n\n                # Method 1: Try to find reply box within comment element structure\n                try:\n                    reply_box_in_comment = comment_element.locator(\"xpath=.//following-sibling::*//p[@dir='auto' and contains(@class, 'xdj266r')] | .//following-sibling::*//div[@contenteditable='true']\").first\n                    if reply_box_in_comment and reply_box_in_comment.count() > 0 and reply_box_in_comment.is_visible():\n                        bbox = reply_box_in_comment.bounding_box()\n                        if bbox and bbox.get('height', 0) > 20:\n                            if self.verify_reply_box_belongs_to_comment(reply_box_in_comment, comment_element):\n                                logger.info('âœ… Found and verified reply box within comment element structure')\n                                return reply_box_in_comment\n                            else:\n                                logger.warning('âš ï¸  Reply box found but verification failed')\n                except Exception as e:\n                    logger.debug(f\"Method 1 failed: {e}\")\n\n                # Method 2: Try to find reply box after comment element\n                try:\n                    reply_box_after = comment_element.locator(\"xpath=./ancestor::div[contains(@role, 'article')]//following-sibling::*[1]//p[@dir='auto' and contains(@class, 'xdj266r')] | ./ancestor::div[contains(@role, 'article')]//following-sibling::*[1]//div[@contenteditable='true']\").first\n                    if reply_box_after and reply_box_after.count() > 0 and reply_box_after.is_visible():\n                        bbox = reply_box_after.bounding_box()\n                        if bbox and bbox.get('height', 0) > 20:\n                            if self.verify_reply_box_belongs_to_comment(reply_box_after, comment_element):\n                                logger.info('âœ… Found and verified reply box after comment element')\n                                return reply_box_after\n                            else:\n                                logger.warning('âš ï¸  Reply box found but verification failed')\n                except Exception as e:\n                    logger.debug(f\"Method 2 failed: {e}\")\n\n                # Method 3: Search all edit boxes and find the closest verified one\n                all_edit_boxes: list[Locator] = self.page.locator(\"//p[@dir='auto' and contains(@class, 'xdj266r')]\").all()\n                if not all_edit_boxes:\n                    all_edit_boxes: list[Locator] = self.page.locator(\"//div[@contenteditable='true']\").all()\n\n                if not all_edit_boxes:\n                    logger.debug(f'Attempt {attempt + 1}: No editable boxes found')\n                    continue\n\n                visible_boxes: list[tuple[Locator, float]] = []\n                for box in all_edit_boxes:\n                    try:\n                        if not box.is_visible():\n                            continue\n                        bbox: Optional[FloatRect] = box.bounding_box()\n                        if not bbox or bbox.get('height', 0) < 20 or bbox.get('width', 0) < 100:\n                            continue\n\n                        aria_label = box.get_attribute('aria-label') or ''\n                        if 'write a comment' in aria_label.lower():\n                            logger.debug('Skipping main comment box')\n                            continue\n\n                        # Verify this box belongs to our comment\n                        if not self.verify_reply_box_belongs_to_comment(box, comment_element):\n                            continue\n\n                        parent = box.locator('xpath=./ancestor::div[3]').first\n                        parent_text = (parent.text_content() or '').lower() if parent else ''\n\n                        box_y = bbox.get('y', 0)\n                        comment_y = comment_bbox.get('y', 0)\n                        comment_height = comment_bbox.get('height', 0)\n\n                        if 'reply to' in parent_text:\n                            distance = abs(box_y - (comment_y + comment_height))\n                            if distance < 300:\n                                logger.info(f\"âœ… Found verified reply box with 'Reply to' text (distance: {distance:.0f}px)\")\n                                visible_boxes.append((box, distance))\n                        elif box_y > comment_y and box_y < comment_y + comment_height + 200:\n                            distance = abs(box_y - (comment_y + comment_height))\n                            logger.debug(f'Found verified box below comment (distance: {distance:.0f}px)')\n                            visible_boxes.append((box, distance))\n                    except Exception as e:\n                        logger.debug(f'Error checking box: {e}')\n                        continue\n\n                if visible_boxes:\n                    visible_boxes.sort(key=lambda x: x[1])\n                    closest_box, distance = visible_boxes[0]\n                    logger.info(f'âœ… Found {len(visible_boxes)} verified reply boxes, using closest (distance: {distance:.0f}px)')\n                    return closest_box\n                else:\n                    logger.debug(f'Attempt {attempt + 1}: No verified reply boxes found near comment')\n            except Exception as e:\n                logger.error(f'Error in attempt {attempt + 1}: {e}')\n                continue\n        logger.error('âŒ No verified reply boxes found after all attempts')\n        return None\n\n    def _type_character_by_character(self, reply_box: Locator, reply_text: str) -> bool:\n        \"\"\"Type text character by character with periodic dialog checks.\"\"\"\n\n        try:\n            for i, char in enumerate(reply_text):\n                try:\n                    # Check for dialog periodically during typing (more frequently)\n                    if (i + 1) % 5 == 0:\n                        if self.handle_leave_page_dialog():\n                            logger.info(f\"Dialog handled during typing at character {i + 1}\")\n                            time.sleep(0.3)\n                        # Also re-setup prevention in case it was cleared\n                        if (i + 1) % 20 == 0:\n                            self.setup_dialog_prevention()\n\n                    if char in [' ', ',', '.', '!', '?']:\n\n                        delay = random.uniform(100, 250)\n                    elif char.isupper():\n\n                        delay = random.uniform(80, 180)\n                    else:\n\n                        delay = random.uniform(50, 120)\n\n                    reply_box.type(char, delay=delay)\n\n                    if (i + 1) % 20 == 0:\n                        logger.debug(f'Typed {i + 1}/{len(reply_text)} characters')\n\n                    if random.random() < 0.05:\n                        time.sleep(random.uniform(0.3, 0.8))\n                except Exception as e:\n                    logger.error(f'Error typing character {i}: {e}')\n                    return False\n\n            reply_box.dispatch_event('input')\n            reply_box.dispatch_event('change')\n            return True\n        except Exception as e:\n            logger.error(f'Character-by-character typing failed: {e}')\n            return False\n    def reply_to_comment(self, comment_data: CommentData, reply_count: int) -> bool:\n\n        max_retries = self.config['MAX_RETRIES']\n        retry_count = 0\n        while retry_count < max_retries:\n            try:\n\n                # Check if we've already successfully replied to this comment\n                if self.db.has_replied_to_comment(comment_data['id']):\n                    reply_text = self.db.get_reply_for_comment(comment_data['id'])\n                    logger.info(f\"âœ… IDEMPOTENCY: Comment {comment_data['id'][:8]} already successfully replied to\")\n                    if reply_text:\n                        logger.info(f\"   Previous reply: {reply_text[:50]}...\")\n                    self.db.log_event('idempotency_check', f\"Skipped duplicate (already replied): {comment_data['id']}\", 'info')\n                    return False\n\n                # Check if processed (but maybe failed)\n                if self.db.is_comment_processed(comment_data['id']):\n                    processed_info = self.db.get_processed_comment(comment_data['id'])\n                    if processed_info:\n                        status = processed_info.get('status', 'unknown')\n                        if status == 'success':\n                            logger.info(f\"âœ… Comment {comment_data['id'][:8]} already successfully processed - skipping\")\n                            return False\n                        else:\n                            logger.info(f\"ðŸ”„ Comment {comment_data['id'][:8]} was processed with status '{status}', will retry\")\n                    else:\n                        logger.info(f\"IDEMPOTENCY: Comment {comment_data['id'][:8]} already processed - skipping\")\n                        self.db.log_event('idempotency_check', f\"Skipped duplicate: {comment_data['id']}\", 'info')\n                        return False\n                if not comment_data['reply_button']:\n                    logger.warning(f\"ðŸ” No reply button initially found for comment {comment_data['id']}, trying to find it again...\")\n\n                    reply_button = self.find_reply_button_advanced(comment_data['element'])\n                    if not reply_button:\n                        reply_button = self.find_reply_button_fallback(comment_data['element'])\n\n                    if reply_button:\n                        logger.info(f\"âœ… Found reply button on retry for comment {comment_data['id']}\")\n                        comment_data['reply_button'] = reply_button\n                    else:\n                        logger.warning(f\"âŒ Still no reply button found for comment {comment_data['id']} after retry\")\n                        self.db.log_event('no_reply_button', f\"Comment: {comment_data['id']}\", 'warning')\n                        return False\n\n                # Improved check for own comment (case-insensitive, checks user_id too)\n                if self.is_own_comment(comment_data.get('author'), comment_data.get('user_id')):\n                    logger.info(f\"ðŸš« Skipping own comment by {comment_data.get('author')} (user_id: {comment_data.get('user_id', 'unknown')[:8] if comment_data.get('user_id') else 'unknown'})\")\n\n                    # Store bot's user_id if we haven't found it yet\n                    if comment_data.get('user_id') and not self.bot_user_id:\n                        self.bot_user_id = comment_data['user_id']\n                        logger.info(f\"âœ… Detected bot's own user_id: {comment_data['user_id'][:8]}\")\n\n                    self.db.add_processed_comment(\n                        comment_data['id'],\n                        comment_data['user_id'],\n                        comment_data['author'] if comment_data['author'] is not None else '',\n                        comment_data['text'],\n                        'SKIPPED_OWN_COMMENT',\n                        status='skipped',\n                        retry_count=0\n                    )\n                    return False\n                logger.info(f\"Attempting to reply to comment by {comment_data['author']} (attempt {retry_count + 1}/{max_retries})\")\n                self.db.log_event('reply_attempt', json.dumps({\n                    'comment_id': comment_data['id'],\n                    'user_id': comment_data['user_id'],\n                    'user_name': comment_data['author'],\n                    'attempt': retry_count + 1\n                }), 'info')\n\n                # Ensure browser is alive before proceeding\n                if not self.ensure_browser_alive():\n                    logger.error(\"âŒ Cannot proceed: Browser is not available\")\n                    if retry_count < max_retries - 1:\n                        retry_count += 1\n                        time.sleep(5)\n                        continue\n                    else:\n                        return False\n\n                # Re-get the element since page might have reloaded\n                try:\n                    # Try to use the stored element, but verify it's still valid\n                    if not self.is_browser_alive():\n                        raise RuntimeError(\"Browser closed\")\n                    comment_data['element'].scroll_into_view_if_needed()\n                except Exception as e:\n                    error_msg = str(e)\n                    if 'closed' in error_msg.lower() or 'Target' in error_msg or 'Browser closed' in error_msg:\n                        logger.error(f\"âŒ Browser/page closed during scroll: {e}\")\n                        if not self.ensure_browser_alive():\n                            if retry_count < max_retries - 1:\n                                retry_count += 1\n                                time.sleep(5)\n                                continue\n                            return False\n                        # After recovery, we need to re-detect the comment\n                        logger.warning(\"âš ï¸  Comment element lost after browser recovery, marking for re-detection\")\n                        self.comment_queue['failed'].append(comment_data['id'])\n                        return False\n                    raise\n\n                self.random_pause(1, 2)\n\n                # Close all other reply boxes first to avoid confusion\n                if self.is_browser_alive():\n                    try:\n                        self.close_all_reply_boxes()\n                    except Exception as e:\n                        if 'closed' in str(e).lower() or 'Target' in str(e):\n                            logger.warning(f\"Browser closed during close_all_reply_boxes: {e}\")\n                            if not self.ensure_browser_alive():\n                                if retry_count < max_retries - 1:\n                                    retry_count += 1\n                                    time.sleep(5)\n                                    continue\n                                return False\n                time.sleep(0.5)\n\n                # Mark this comment element with a unique identifier before clicking\n                comment_id = comment_data.get('id', '')\n                try:\n                    comment_data['element'].evaluate(f\"\"\"\n                        (el) => {{\n                            el.setAttribute('data-bot-replying-to', '{comment_id}');\n                            el.setAttribute('data-bot-reply-timestamp', '{datetime.now().timestamp()}');\n                        }}\n                    \"\"\")\n                except:\n                    pass\n\n                # Check browser before clicking\n                if not self.is_browser_alive():\n                    logger.error(\"âŒ Browser closed before clicking reply button\")\n                    if not self.ensure_browser_alive():\n                        if retry_count < max_retries - 1:\n                            retry_count += 1\n                            time.sleep(5)\n                            continue\n                        return False\n\n                try:\n                    comment_data['reply_button'].scroll_into_view_if_needed()\n                    time.sleep(0.5)\n                    self.human_mouse_jiggle(comment_data['reply_button'], moves=1)\n                    comment_data['reply_button'].click(timeout=3000)\n                    logger.info('âœ… Clicked reply button')\n                except Exception as e:\n                    error_msg = str(e)\n                    if 'closed' in error_msg.lower() or 'Target' in error_msg:\n                        logger.error(f\"âŒ Browser/page closed during click: {e}\")\n                        if not self.ensure_browser_alive():\n                            if retry_count < max_retries - 1:\n                                retry_count += 1\n                                time.sleep(5)\n                                continue\n                            return False\n                        # Continue to next attempt\n                        continue\n                    logger.info(f'Regular click failed ({e}), using JavaScript click')\n                    try:\n                        comment_data['reply_button'].evaluate('el => el.click()')\n                    except Exception as js_e:\n                        if 'closed' in str(js_e).lower():\n                            logger.error(f\"âŒ Browser closed during JS click: {js_e}\")\n                            if not self.ensure_browser_alive():\n                                if retry_count < max_retries - 1:\n                                    retry_count += 1\n                                    time.sleep(5)\n                                    continue\n                                return False\n                            continue\n                        raise\n\n                logger.info('Waiting for reply box to appear...')\n                self.random_pause(2, 3)\n\n                # Check browser before proceeding\n                if not self.is_browser_alive():\n                    logger.error(\"âŒ Browser closed while waiting for reply box\")\n                    if not self.ensure_browser_alive():\n                        if retry_count < max_retries - 1:\n                            retry_count += 1\n                            time.sleep(5)\n                            continue\n                        return False\n\n                # Use JavaScript to find the reply box that was just opened\n                try:\n                    if not self.page:\n                        raise RuntimeError(\"Page is None\")\n                    reply_box_js = self.page.evaluate(f\"\"\"\n                        (function() {{\n                            // Find the comment we just clicked reply on\n                            const targetComment = document.querySelector('[data-bot-replying-to=\"{comment_id}\"]');\n                            if (!targetComment) return null;\n\n                            // Find all visible reply boxes\n                            const allReplyBoxes = Array.from(document.querySelectorAll('p[dir=\"auto\"][class*=\"xdj266r\"], div[contenteditable=\"true\"]'));\n\n                            // Filter to only visible ones\n                            const visibleBoxes = allReplyBoxes.filter(box => {{\n                                const style = window.getComputedStyle(box);\n                                return style.display !== 'none' && style.visibility !== 'hidden' && box.offsetHeight > 20;\n                            }});\n\n                            if (visibleBoxes.length === 0) return null;\n\n                            // Get comment position\n                            const commentRect = targetComment.getBoundingClientRect();\n                            const commentBottom = commentRect.bottom;\n\n                            // Find the reply box closest to and below this comment\n                            let bestBox = null;\n                            let bestDistance = Infinity;\n\n                            for (const box of visibleBoxes) {{\n                                const boxRect = box.getBoundingClientRect();\n                                const boxTop = boxRect.top;\n\n                                // Box should be below the comment\n                                if (boxTop < commentBottom) continue;\n\n                                // Check if box is within the same article/thread\n                                let current = box;\n                                let foundComment = false;\n                                for (let i = 0; i < 10; i++) {{\n                                    current = current.parentElement;\n                                    if (!current) break;\n                                    if (current === targetComment || current.contains(targetComment)) {{\n                                        foundComment = true;\n                                        break;\n                                    }}\n                                }}\n\n                                if (!foundComment) {{\n                                    // Check if they're in the same article\n                                    const commentArticle = targetComment.closest('[role=\"article\"]');\n                                    const boxArticle = box.closest('[role=\"article\"]');\n                                    if (commentArticle && boxArticle && commentArticle !== boxArticle) {{\n                                        continue;\n                                    }}\n                                }}\n\n                                const distance = boxTop - commentBottom;\n                                if (distance < bestDistance && distance < 500) {{\n                                    bestDistance = distance;\n                                    bestBox = box;\n                                }}\n                            }}\n\n                            if (bestBox) {{\n                                // Mark this box so we can find it\n                                bestBox.setAttribute('data-bot-selected-reply-box', 'true');\n                                return true;\n                            }}\n\n                            return false;\n                        }})();\n                    \"\"\")\n\n                    if reply_box_js:\n                        logger.info('âœ… JavaScript found the reply box')\n                except Exception as e:\n                    logger.debug(f\"JavaScript reply box finder failed: {e}\")\n\n                comment_author = comment_data.get('author', 'Unknown')\n                logger.info(f'Looking for reply box for comment by {comment_author}')\n\n                reply_box = self.find_reply_input_box(comment_data['element'])\n                if not reply_box:\n                    logger.error(f'Could not find reply input box (attempt {retry_count + 1})')\n                    if retry_count < max_retries - 1:\n                        logger.info('Retrying...')\n                        retry_count += 1\n\n                        try:\n                            if self.page:\n                                self.page.keyboard.press('Escape')\n                            time.sleep(1)\n                        except:\n                            pass\n                        continue\n                    else:\n                        if self.page:\n                            if self.is_browser_alive() and self.page:\n                                try:\n                                    self.page.screenshot(path=f'debug_no_reply_box_{reply_count}.png')\n                                except Exception:\n                                    pass\n                        self.db.log_event('reply_failed', f\"No reply box: {comment_data['id']}\", 'error')\n\n                        self.db.add_processed_comment(\n                            comment_data['id'],\n                            comment_data['user_id'],\n                            comment_data['author'] if comment_data['author'] is not None else '',\n                            comment_data['text'],\n                            'FAILED_NO_REPLY_BOX',\n                            status='failed',\n                            retry_count=retry_count\n                        )\n                        return False\n\n                # Final verification that this reply box belongs to the correct comment\n                if not self.verify_reply_box_belongs_to_comment(reply_box, comment_data['element']):\n                    logger.error(f'âŒ Reply box verification failed - this box does not belong to comment by {comment_data.get(\"author\")}')\n                    logger.error(f'   Comment text: {comment_data.get(\"text\", \"\")[:50]}...')\n                    if retry_count < max_retries - 1:\n                        logger.warning('Retrying with fresh search...')\n                        retry_count += 1\n                        try:\n                            if self.page:\n                                self.page.keyboard.press('Escape')\n                            time.sleep(1)\n                        except:\n                            pass\n                        continue\n                    else:\n                        logger.error('Failed to find correct reply box after all retries')\n                        return False\n\n                # Check if reply box is empty or has unexpected content (like @mentions)\n                try:\n                    existing_text = reply_box.evaluate('(el) => el.textContent || el.innerText || el.value || \"\"')\n                    if existing_text and len(existing_text.strip()) > 0:\n                        # Check if it contains a mention/tag (starts with @)\n                        if existing_text.strip().startswith('@'):\n                            logger.warning(f'âš ï¸  Reply box contains mention/tag: \"{existing_text[:50]}...\" - clearing it')\n                            # Clear the mention\n                            reply_box.evaluate('(el) => { el.textContent = \"\"; el.innerText = \"\"; if(el.value) el.value = \"\"; }')\n                            time.sleep(0.3)\n                        else:\n                            logger.info(f'Reply box has existing text: \"{existing_text[:50]}...\" - will clear before typing')\n                except:\n                    pass\n\n                # Final check: Verify the reply box is still the correct one\n                if not self.verify_reply_box_belongs_to_comment(reply_box, comment_data['element']):\n                    logger.error('âŒ Reply box verification failed after finding - retrying...')\n                    if retry_count < max_retries - 1:\n                        retry_count += 1\n                        try:\n                            if self.page:\n                                self.page.keyboard.press('Escape')\n                            time.sleep(1)\n                        except:\n                            pass\n                        continue\n                    else:\n                        logger.error('Failed to find correct reply box after all retries')\n                        return False\n\n                logger.info(f'âœ… Found and verified reply input box for comment by {comment_data.get(\"author\")}')\n                logger.info(f'ðŸ“ Comment we\\'re replying to: \"{comment_data.get(\"text\", \"\")[:50]}...\"')\n                logger.info('Found reply input box, generating reply...')\n\n                # Check for dialog before starting\n                self.handle_leave_page_dialog()\n\n                # Get post content for context-aware reply generation\n                post_content = self.get_post_content()\n                reply_text = self.generate_reply(comment_data['text'], post_content)\n                logger.info(f'Typing reply: {reply_text[:50]}...')\n\n                try:\n                    reply_box.focus()\n                    time.sleep(0.5)\n                    # Check for dialog after focus\n                    self.handle_leave_page_dialog()\n                    reply_box.click()\n                    time.sleep(0.3)\n\n                    try:\n                        reply_box.press('Control+A')\n                        time.sleep(0.2)\n                        reply_box.press('Delete')\n                        time.sleep(0.2)\n                    except:\n                        pass\n\n                    logger.info('Clearing any pre-filled content...')\n                    try:\n                        reply_box.evaluate('(el) => { el.textContent = \"\"; el.innerText = \"\"; if(el.value) el.value = \"\"; }')\n                        time.sleep(0.2)\n                        reply_box.press('Control+A')\n                        time.sleep(0.1)\n                        reply_box.press('Backspace')\n                        time.sleep(0.2)\n                    except:\n                        pass\n\n                    logger.info(f'Trying to insert reply text: {reply_text[:50]}...')\n\n                    logger.info('Method 1: Using evaluate with textContent...')\n                    try:\n                        escaped = reply_text.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"').replace(\"'\", \"\\\\'\").replace('\\n', ' ').replace('\\r', '')\n                        reply_box.evaluate(f'''\n                            (el) => {{\n                                el.textContent = \"{escaped}\";\n                                el.innerText = \"{escaped}\";\n                                if(el.value !== undefined) el.value = \"{escaped}\";\n                                el.dispatchEvent(new Event(\"input\", {{ bubbles: true, cancelable: true }}));\n                                el.dispatchEvent(new Event(\"keyup\", {{ bubbles: true, cancelable: true }}));\n                                el.dispatchEvent(new Event(\"change\", {{ bubbles: true, cancelable: true }}));\n                            }}\n                        ''')\n                        time.sleep(0.5)\n\n                        actual = reply_box.evaluate('(el) => el.textContent || el.innerText || el.value || \"\"')\n                        if reply_text.strip().lower() in str(actual).lower() or (len(str(actual).strip()) > len(reply_text.strip()) * 0.5):\n                            logger.info(f'âœ“ Method 1 successful. Text in box: {actual[:50]}...')\n                            typing_successful = True\n                        else:\n                            raise Exception(f'Text not set. Got: {actual[:50]}')\n                    except Exception as e1:\n                        logger.warning(f'Method 1 failed: {e1}')\n                        typing_successful = False\n\n                    if not typing_successful:\n                        logger.info('Method 2: Using fill()...')\n                        try:\n                            reply_box.fill('')\n                            time.sleep(0.2)\n                            reply_box.fill(reply_text)\n                            time.sleep(0.4)\n                            reply_box.dispatch_event('input', {'bubbles': True})\n                            reply_box.dispatch_event('keyup', {'bubbles': True})\n                            reply_box.dispatch_event('change', {'bubbles': True})\n                            time.sleep(0.3)\n\n                            actual = reply_box.evaluate('(el) => el.textContent || el.innerText || el.value || \"\"')\n                            if reply_text.strip().lower() in str(actual).lower() or len(str(actual).strip()) > 3:\n                                logger.info(f'âœ“ Method 2 successful. Text in box: {actual[:50]}...')\n                                typing_successful = True\n                            else:\n                                raise Exception(f'Text not set. Got: {actual[:50]}')\n                        except Exception as fill_error:\n                            logger.warning(f'Method 2 failed: {fill_error}')\n                            typing_successful = False\n\n                    if not typing_successful:\n                        logger.info('Trying innerHTML manipulation...')\n                        try:\n                            escaped_text = reply_text.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"').replace('\\n', '\\\\n').replace('\\r', '')\n                            reply_box.evaluate(f'(element) => {{ element.textContent = \"{escaped_text}\"; element.innerText = \"{escaped_text}\"; element.dispatchEvent(new Event(\"input\", {{ bubbles: true }})); element.dispatchEvent(new Event(\"keyup\", {{ bubbles: true }})); }}')\n                            time.sleep(0.5)\n\n                            actual_text = reply_box.evaluate('(el) => el.textContent || el.innerText || \"\"')\n                            if reply_text.lower().strip() in str(actual_text).lower():\n                                logger.info('âœ“ Used innerHTML method successfully')\n                                typing_successful = True\n                            else:\n                                raise Exception('Text not properly set')\n                        except Exception as inner_error:\n                            logger.warning(f'innerHTML method failed: {inner_error}')\n                            typing_successful = False\n\n                    if not typing_successful:\n                        logger.info('Trying type() method...')\n                        try:\n                            reply_box.clear()\n                            time.sleep(0.2)\n                            reply_box.type(reply_text, delay=30)\n                            time.sleep(0.3)\n\n                            reply_box.dispatch_event('input', {'bubbles': True})\n                            reply_box.dispatch_event('change', {'bubbles': True})\n                            reply_box.dispatch_event('keyup', {'bubbles': True})\n                            time.sleep(0.2)\n\n                            actual_text = reply_box.input_value() if hasattr(reply_box, 'input_value') else reply_box.evaluate('(el) => el.textContent || el.innerText || \"\"')\n                            if reply_text.lower().strip() in str(actual_text).lower():\n                                logger.info('âœ“ Used type() method successfully')\n                                typing_successful = True\n                            else:\n                                raise Exception('Text not properly set')\n                        except Exception as type_error:\n                            logger.warning(f'Type method failed: {type_error}')\n                            typing_successful = False\n\n                    if not typing_successful:\n                        logger.info('Using character-by-character fallback...')\n                        typing_successful = self._type_character_by_character(reply_box, reply_text)\n\n                    # Check for dialog after typing attempts\n                    self.handle_leave_page_dialog()\n\n                except Exception as e:\n                    logger.warning(f'Could not focus on reply box: {e}')\n                    typing_successful = False\n\n                if not typing_successful:\n                    logger.error('All typing methods failed')\n                    return False\n\n                time.sleep(1.0)\n                # Check for dialog before verification\n                self.handle_leave_page_dialog()\n                try:\n                    final_text = reply_box.evaluate('(el) => el.textContent || el.innerText || el.value || \"\"')\n                    final_text_str = str(final_text).strip()\n\n                    if not final_text_str or len(final_text_str) < 3:\n                        logger.error(f'Reply text is empty after typing. Expected: {reply_text[:50]}')\n                        logger.error(f'Actual content in box: \"{final_text_str}\"')\n                        return False\n\n                    if reply_text.strip().lower() not in final_text_str.lower() and len(final_text_str) < len(reply_text.strip()) * 0.5:\n                        logger.warning(f'Reply text mismatch. Expected: {reply_text[:50]}... Got: {final_text_str[:50]}...')\n                        logger.warning('Text might have been modified by Facebook, but proceeding...')\n\n                    logger.info(f'âœ“ Verified reply text in box: {final_text_str[:50]}...')\n\n                    # Final verification: Make sure we're still in the correct reply box\n                    if not self.verify_reply_box_belongs_to_comment(reply_box, comment_data['element']):\n                        logger.error('âŒ Reply box changed during typing! This is the wrong comment.')\n                        logger.error(f'   Expected comment: {comment_data.get(\"author\")} - \"{comment_data.get(\"text\", \"\")[:50]}...\"')\n                        return False\n                    logger.info(f'âœ“ Confirmed this is still the reply box for comment by {comment_data.get(\"author\")}')\n                except Exception as e:\n                    logger.warning(f'Could not verify reply text: {e}')\n\n                logger.info('Finished typing, waiting 1 second before submit...')\n                time.sleep(1.0)\n                # Check for dialog before submission\n                self.handle_leave_page_dialog()\n\n                submitted = False\n\n                time.sleep(1)\n\n                try:\n\n                    submit_selectors = [\n                        'xpath=./ancestor::div[contains(@class, \"x1n2onr6\")]//div[@role=\"button\" and @aria-label=\"Comment\"]',\n                        'xpath=./following-sibling::div[@role=\"button\" and @aria-label=\"Comment\"]',\n                        'xpath=./parent::*/following-sibling::*//div[@role=\"button\" and @aria-label=\"Comment\"]',\n                        'xpath=./..//div[@role=\"button\" and contains(@class, \"x1i10hfl\")]'\n                    ]\n\n                    submit_button = None\n                    for selector in submit_selectors:\n                        try:\n                            btn = reply_box.locator(selector).first\n                            if btn.is_visible():\n                                submit_button = btn\n                                logger.info(f'Found submit button with selector: {selector}')\n                                break\n                        except:\n                            continue\n\n                    if submit_button:\n                        is_disabled = submit_button.get_attribute('aria-disabled')\n                        logger.info(f'Submit button disabled status: {is_disabled}')\n                        if is_disabled == 'false' or is_disabled is None:\n                            logger.info('Submit button is enabled, clicking it directly')\n                            submit_button.click()\n                            self.random_pause(3, 5)\n                            logger.info('âœ“ Submitted with submit button click')\n                            submitted = True\n                        else:\n                            logger.warning('Submit button still disabled, trying keyboard shortcuts')\n                    else:\n                        logger.warning('Could not find submit button, will try keyboard methods')\n                except Exception as btn_error:\n                    logger.debug(f'Could not check submit button: {btn_error}')\n\n                if 'submitted' not in locals():\n                    submitted = False\n\n                self.random_pause(1, 2)\n\n                if not submitted:\n                    logger.info('Submitting reply...')\n\n                    try:\n                        logger.info('Trying Ctrl+Enter...')\n                        reply_box.press('Control+Enter')\n                        submitted = True\n                        logger.info('âœ“ Submitted with Ctrl+Enter')\n                    except Exception as e:\n                        logger.warning(f'Ctrl+Enter failed: {e}')\n\n                    if not submitted:\n                        try:\n                            logger.info('Trying Enter key...')\n                            reply_box.press('Enter')\n                            submitted = True\n                            logger.info('âœ“ Submitted with Enter')\n                        except Exception as e:\n                            logger.warning(f'Enter key failed: {e}')\n\n                if not submitted:\n                    try:\n                        logger.info('Looking for submit button...')\n\n                        reply_container = reply_box.locator('xpath=./ancestor::div[contains(@class, \"x1n2onr6\") or contains(@role, \"textbox\") or contains(@contenteditable, \"true\")]//following-sibling::*[1] | ./ancestor::div[contains(@class, \"x1n2onr6\") or contains(@role, \"textbox\")]//parent::*/following-sibling::*[1]').first\n\n                        submit_selectors = [\n\n                            \"//div[@role='button' and @aria-label]\",\n                            \"//div[@role='button' and contains(@class, 'x1i10hfl')]\",\n                            \"//div[contains(@style, 'cursor: pointer') and @role='button']\",\n\n                            \"//div[@role='button' and (contains(text(), 'Post') or contains(text(), 'Reply') or contains(text(), 'Send') or contains(text(), 'Submit'))]\",\n                            \"//button[contains(text(), 'Post') or contains(text(), 'Reply') or contains(text(), 'Send')]\",\n\n                            \"//div[@aria-label='Post' or @aria-label='Reply' or @aria-label='Send' or @aria-label='Submit' or contains(@aria-label, 'Send') or contains(@aria-label, 'Post')]\",\n                        ]\n\n                        for selector in submit_selectors:\n                            try:\n                                if reply_container:\n                                    submit_buttons = reply_container.locator(selector).all()\n                                else:\n\n                                    submit_buttons = reply_box.locator(f'xpath=./ancestor::div[3]//{selector[2:]}').all()\n\n                                for btn in submit_buttons:\n                                    try:\n                                        if btn.is_visible():\n                                            btn_text = btn.text_content() or ''\n                                            btn_label = btn.get_attribute('aria-label') or ''\n                                            logger.info(f'Found potential submit button - Text: \"{btn_text}\", Aria-label: \"{btn_label}\"')\n\n                                            btn.click(timeout=2000)\n                                            submitted = True\n                                            logger.info('âœ“ Submitted with button click')\n                                            break\n                                    except Exception as btn_error:\n                                        logger.debug(f'Button click failed: {btn_error}')\n                                        continue\n                                if submitted:\n                                    break\n                            except Exception as selector_error:\n                                logger.debug(f'Selector failed: {selector_error}')\n                                continue\n\n                        if not submitted:\n                            logger.info('Trying broader page search for submit button...')\n                            page_submit_buttons = self.page.locator(\"//div[@role='button' and (@aria-label or contains(@class, 'x1i10hfl'))]\").all()\n                            for btn in page_submit_buttons:\n                                try:\n                                    if btn.is_visible():\n                                        btn_bbox = btn.bounding_box()\n                                        reply_bbox = reply_box.bounding_box()\n                                        if btn_bbox and reply_bbox:\n\n                                            distance = abs(btn_bbox['x'] - reply_bbox['x']) + abs(btn_bbox['y'] - reply_bbox['y'])\n                                            if distance < 100:\n                                                logger.info(f'Found nearby button at distance {distance}px')\n                                                btn.click(timeout=2000)\n                                                submitted = True\n                                                logger.info('âœ“ Submitted with nearby button click')\n                                                break\n                                except Exception as page_btn_error:\n                                    logger.debug(f'Page button failed: {page_btn_error}')\n                                    continue\n\n                    except Exception as e:\n                        logger.warning(f'Submit button search failed: {e}')\n\n                if not submitted:\n                    logger.warning('All submission methods failed, trying coordinate-based click as final attempt')\n                    try:\n\n                        reply_bbox = reply_box.bounding_box()\n                        if reply_bbox and self.page:\n\n                            submit_x = reply_bbox['x'] + reply_bbox['width'] + 10\n                            submit_y = reply_bbox['y'] + reply_bbox['height'] / 2\n                            logger.info(f'Trying coordinate click at ({submit_x}, {submit_y})')\n                            self.page.mouse.click(submit_x, submit_y)\n                            submitted = True\n                            logger.info('âœ“ Submitted with coordinate click')\n                    except Exception as coord_error:\n                        logger.warning(f'Coordinate click failed: {coord_error}')\n\n                        try:\n                            if self.page:\n                                self.page.keyboard.press('Control+Enter')\n                        except:\n                            pass\n\n                self.random_pause(3, 5)\n\n                # Check for dialog after submission using the dedicated function\n                if self.handle_leave_page_dialog():\n                    logger.warning(\"Found 'Stay on Page' dialog after submission - retrying\")\n                    time.sleep(1)\n                    if retry_count < max_retries - 1:\n                        retry_count += 1\n                        continue\n                    else:\n                        self.db.log_event('reply_failed', f\"Stay dialog: {comment_data['id']}\", 'error')\n                        return False\n\n                timestamp = datetime.now().isoformat()\n                logger.info(f'SUCCESS - Comment Replied')\n                logger.info(f\"Comment ID: {comment_data['id']}\")\n                logger.info(f\"User ID: {comment_data['user_id']}\")\n                logger.info(f\"User Name: {comment_data['author']}\")\n                logger.info(f'Timestamp: {timestamp}')\n                logger.info(f'Reply: {reply_text}')\n                # Add to database with success status\n                self.db.add_processed_comment(\n                    comment_data['id'],\n                    comment_data['user_id'],\n                    comment_data['author'] if comment_data['author'] is not None else '',\n                    comment_data['text'],\n                    reply_text,\n                    status='success',\n                    retry_count=retry_count\n                )\n\n                # Verify it was saved\n                saved_reply = self.db.get_reply_for_comment(comment_data['id'])\n                if saved_reply:\n                    logger.info(f\"âœ… Reply saved to database for comment {comment_data['id'][:8]}\")\n                else:\n                    logger.warning(f\"âš ï¸  Reply may not have been saved to database for comment {comment_data['id'][:8]}\")\n\n                self.db.update_user_stats(comment_data['user_id'], comment_data['author'] if comment_data['author'] is not None else '')\n                self.db.add_rate_limit_entry()\n                self.db.log_event('reply_success', json.dumps({\n                    'comment_id': comment_data['id'],\n                    'user_id': comment_data['user_id'],\n                    'user_name': comment_data['author'],\n                    'reply': reply_text,\n                    'timestamp': timestamp,\n                    'retry_count': retry_count\n                }), 'info')\n                logger.info(f\"Reply {reply_count} posted successfully\")\n                return True\n            except Exception as e:\n                logger.error(f'Error replying to comment (attempt {retry_count + 1}): {e}')\n                import traceback\n                logger.error(traceback.format_exc())\n                self.db.log_event('reply_error', json.dumps({\n                    'comment_id': comment_data['id'],\n                    'error': str(e),\n                    'attempt': retry_count + 1\n                }), 'error')\n                if retry_count < max_retries - 1:\n                    logger.info(f'Retrying in 5 seconds... (attempt {retry_count + 2}/{max_retries})')\n                    time.sleep(5)\n                    retry_count += 1\n\n                    try:\n                        if self.page:\n                            self.page.keyboard.press('Escape')\n                    except:\n                        pass\n                else:\n                    # Only take screenshot if browser is still alive\n                    if self.is_browser_alive() and self.page:\n                        try:\n                            self.page.screenshot(path=f'error_{reply_count}.png')\n                        except Exception:\n                            logger.debug(\"Could not take error screenshot - browser may be closed\")\n\n                    self.db.add_processed_comment(\n                        comment_data['id'],\n                        comment_data['user_id'],\n                        comment_data['author'] if comment_data['author'] is not None else '',\n                        comment_data['text'],\n                        f'FAILED: {str(e)}',\n                        status='failed',\n                        retry_count=retry_count\n                    )\n                    return False\n        return False\n    def run(self):\n\n        self.setup_driver()\n        if not self.page:\n            logger.error(\"Page not initialized after setup_driver. Exiting.\")\n            return\n        try:\n\n            self.page.set_default_timeout(30000)\n\n            post_url = self.config.get('POST_URL')\n            if not post_url:\n                logger.error('POST_URL is not configured. Set POST_URL in .env or config.')\n                return\n            logger.info(f\"Loading Facebook post URL: {post_url}\")\n\n            try:\n                self.page.goto(\n                    post_url,\n                    wait_until='domcontentloaded',\n                    timeout=30000\n                )\n                logger.info(\"âœ“ Page loaded successfully\")\n            except Exception as e:\n                logger.warning(f\"Page load timeout, but continuing: {e}\")\n\n            try:\n                self.page.wait_for_selector(\"//div[@role='main']\", timeout=10000)\n                logger.info(\"âœ“ Facebook main content detected\")\n            except:\n                logger.warning(\"Main content not detected quickly, but continuing...\")\n\n            # Setup dialog prevention as soon as page loads\n            self.setup_dialog_prevention()\n\n            stats: Statistics = cast(Statistics, self.db.get_statistics())\n            logger.info(f\"\\n{'='*60}\")\n            logger.info(f\"INITIAL STATISTICS\")\n            logger.info(f\"{'='*60}\")\n            logger.info(f\"Total comments processed: {stats.get('total_comments', 0)}\")\n            logger.info(f\"Unique users replied to: {stats.get('unique_users', 0)}\")\n            logger.info(f\"Successful replies: {stats.get('successful', 0)}\")\n            logger.info(f\"Failed replies: {stats.get('failed', 0)}\")\n            logger.info(f\"{'='*60}\\n\")\n\n            logger.info(\"Waiting for page to stabilize...\")\n            self.random_pause(2, 4)\n\n            # Extract and cache post content early\n            logger.info(\"ðŸ“„ Extracting post content for context-aware replies...\")\n            post_content = self.get_post_content()\n            if post_content:\n                logger.info(f\"âœ… Post content cached ({len(post_content)} characters)\")\n            else:\n                logger.warning(\"âš ï¸  Could not extract post content - replies will use comment-only context\")\n\n            reply_count = 0\n            iteration = 0\n\n            run_continuously = self.config.get('RUN_CONTINUOUSLY', True)\n            if run_continuously:\n                logger.info('ðŸ¤– ADVANCED CONTINUOUS MODE: Intelligent comment detection and priority-based processing')\n                logger.info('âœ¨ Features: Smart detection, priority queue, adaptive timing, real-time metrics')\n                logger.info('Press Ctrl+C to stop the bot gracefully\\n')\n\n            while iteration < self.config['MAX_ITERATIONS']:\n                if not run_continuously and reply_count >= self.config['MAX_REPLIES']:\n                    logger.info('Max replies reached.')\n                    break\n\n                iteration += 1\n                logger.info(f\"\\nðŸ” SCAN {iteration}: Advanced Comment Detection\")\n                logger.info(f\"{'='*60}\")\n\n                try:\n                    rate_ok, rate_msg = self.check_rate_limit()\n                    if not rate_ok:\n                        logger.warning(f\"ðŸš« {rate_msg}\")\n\n                        logger.info('âš ï¸  Rate limit check failed, continuing in offline mode...')\n                except Exception as e:\n                    logger.debug(f\"Rate limit check failed (offline mode), continuing: {e}\")\n\n                new_comments = self.smart_comment_detection()\n                logger.info(f\"ðŸ” Detection result: {len(new_comments)} comments detected\")\n\n                if new_comments:\n                    logger.info(f\"ðŸ“¥ Adding {len(new_comments)} comments to queue...\")\n                    self.add_comments_to_queue(new_comments)\n                    logger.info(f\"ðŸŽ¯ Found {len(new_comments)} new comments, queue now has {len(self.comment_queue['pending'])} pending\")\n                else:\n                    logger.debug(\"No new comments detected in this scan\")\n\n                max_queue_iterations = 50\n                for queue_iter in range(max_queue_iterations):\n                    if not self.comment_queue['pending']:\n                        if queue_iter > 0:\n                            logger.info(f\"âœ… Queue empty after {queue_iter} processing iterations\")\n                        break\n\n                    pending_count = len(self.comment_queue['pending'])\n                    logger.info(f\"ðŸ“‹ Queue processing iteration {queue_iter + 1}/{max_queue_iterations} ({pending_count} pending comments)\")\n                    processed_any = self.process_comment_queue()\n\n                    if processed_any:\n\n                        completed_count = len(self.comment_queue['completed'])\n                        reply_count = completed_count\n                        remaining = len(self.comment_queue['pending'])\n                        logger.info(f\"âœ… Processed comments: {completed_count} completed, {remaining} remaining\")\n                    else:\n\n                        if len(self.comment_queue['pending']) > 0:\n                            logger.warning(f\"âš ï¸  No comments processed but {len(self.comment_queue['pending'])} still pending - retrying...\")\n\n                            self.random_pause(1, 2)\n                        else:\n                            break\n\n                    if len(self.comment_queue['pending']) > 0:\n                        self.random_pause(0.5, 1.0)\n\n                if random.random() < 0.3:\n                    self.simulate_human_activity()\n\n                if iteration % 3 == 0:\n                    self.print_queue_status()\n\n                self.update_adaptive_scan_interval()\n\n                if iteration % 5 == 0:\n                    self.db.clean_old_rate_limit_entries(self.config['RATE_LIMIT_WINDOW'])\n\n                if len(self.comment_queue['pending']) > 0:\n\n                    wait_time = min(self.adaptive_scan_interval, 10.0)\n                    logger.info(f\"â±ï¸  Pending comments detected - short wait: {wait_time:.1f}s\")\n                else:\n                    wait_time = self.adaptive_scan_interval\n                    logger.info(f\"ðŸ’¤ No pending comments - adaptive wait: {wait_time:.1f}s\")\n\n                time.sleep(wait_time)\n\n                if iteration % 15 == 0:\n                    logger.info('ðŸ”„ Smart page refresh...')\n                    if self.page:\n                        self.page.reload()\n                    self.random_pause(3, 6)\n\n            logger.info(f\"\\nðŸ FINAL ADVANCED STATISTICS\")\n            logger.info(f\"{'='*60}\")\n            stats: Statistics = cast(Statistics, self.db.get_statistics())\n            logger.info(f\"ðŸ“Š Total comments processed: {stats.get('total_comments', 0)}\")\n            logger.info(f\"ðŸ‘¥ Unique users replied to: {stats.get('unique_users', 0)}\")\n            logger.info(f\"âœ… Successful replies: {stats.get('successful', 0)}\")\n            logger.info(f\"âŒ Failed replies: {stats.get('failed', 0)}\")\n            logger.info(f\"ðŸš€ Session replies: {len(self.comment_queue['completed'])}\")\n\n            logger.info(f\"\\nâš¡ PERFORMANCE METRICS\")\n            logger.info(f\"{'='*60}\")\n            logger.info(f\"ðŸ” Total scans performed: {self.detection_metrics['total_scans']}\")\n            logger.info(f\"ðŸ“ˆ Comments detected: {self.detection_metrics['comments_detected']}\")\n            logger.info(f\"â±ï¸  Average scan time: {self.detection_metrics['processing_time_avg']:.2f}s\")\n\n            if self.detection_metrics['total_scans'] > 0:\n                detection_rate = self.detection_metrics['new_comments_found'] / self.detection_metrics['total_scans']\n                logger.info(f\"ðŸŽ¯ Detection efficiency: {detection_rate:.2f} comments/scan\")\n\n            logger.info(f\"\\nðŸ“‹ FINAL QUEUE STATUS\")\n            logger.info(f\"{'='*60}\")\n            logger.info(f\"ðŸ“¥ Remaining pending: {len(self.comment_queue['pending'])}\")\n            logger.info(f\"âœ… Total completed: {len(self.comment_queue['completed'])}\")\n            logger.info(f\"âŒ Total failed: {len(self.comment_queue['failed'])}\")\n\n            if len(self.comment_queue['completed']) + len(self.comment_queue['failed']) > 0:\n                success_rate = len(self.comment_queue['completed']) / (len(self.comment_queue['completed']) + len(self.comment_queue['failed']))\n                logger.info(f\"ðŸ“ˆ Session success rate: {success_rate:.1%}\")\n\n            logger.info(f\"{'='*60}\\n\")\n        except KeyboardInterrupt:\n            logger.info(\"\\nðŸ›‘ Bot stopped by user (Ctrl+C)\")\n            logger.info(\"ðŸ“Š Saving final state and cleanup...\")\n\n            if len(self.comment_queue['pending']) > 0:\n                logger.info(f\"ðŸ’¾ {len(self.comment_queue['pending'])} comments remain in queue\")\n\n        except Exception as e:\n            logger.critical(f'âŒ Bot execution failed: {e}')\n            import traceback\n            logger.critical(traceback.format_exc())\n            self.db.log_event('bot_crash', str(e), 'critical')\n\n            logger.error(f\"ðŸ†˜ Emergency status - Pending: {len(self.comment_queue['pending'])}\")\n            logger.error(f\"ðŸ†˜ Emergency status - Processing: {len(self.comment_queue['processing'])}\")\n\n        finally:\n            if self.browser:\n                logger.info('Closing browser...')\n                self.browser.close()\n                logger.info('Browser closed.')\n            if self.playwright:\n                logger.info('Stopping Playwright...')\n                self.playwright.stop()\n                logger.info('Playwright stopped.')\n\n            self.db.close()\n            logger.info('Database connection closed.')\n            self.db.log_event('bot_shutdown', 'Bot stopped gracefully', 'info')\ndef main():\n\n    try:\n        bot = FacebookAIReplyBot()\n        bot.run()\n    except Exception as e:\n        logger.critical(f'Bot initialization failed: {e}')\nif __name__ == '__main__':\n    main()\n","size_bytes":155957},"utils/retry.py":{"content":"\"\"\"\nRetry decorator and utilities for robust error handling.\n\"\"\"\nimport time\nimport logging\nfrom functools import wraps\nfrom typing import Callable, TypeVar, ParamSpec, Any\n\nlogger = logging.getLogger(__name__)\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\n\ndef retry_with_backoff(\n    max_retries: int = 3,\n    initial_delay: float = 1.0,\n    backoff_factor: float = 2.0,\n    exceptions: tuple[type[Exception], ...] = (Exception,)\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"\n    Retry decorator with exponential backoff.\n\n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for delay after each retry\n        exceptions: Tuple of exceptions to catch and retry on\n\n    Returns:\n        Decorated function with retry logic\n    \"\"\"\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            delay = initial_delay\n            last_exception: Exception | None = None\n\n            for attempt in range(max_retries):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_retries - 1:\n                        logger.warning(\n                            f\"{func.__name__} failed (attempt {attempt + 1}/{max_retries}): {e}. \"\n                            f\"Retrying in {delay:.2f}s...\"\n                        )\n                        time.sleep(delay)\n                        delay *= backoff_factor\n                    else:\n                        logger.error(f\"{func.__name__} failed after {max_retries} attempts: {e}\")\n\n            if last_exception:\n                raise last_exception\n            raise RuntimeError(f\"{func.__name__} failed after {max_retries} attempts\")\n\n        return wrapper\n    return decorator\n\n","size_bytes":1944},"utils/__init__.py":{"content":"\"\"\"\nUtility modules for the Facebook AI Reply Bot.\n\"\"\"\nfrom .logger import setup_logger\nfrom .retry import retry_with_backoff\nfrom .validators import validate_comment_id, validate_user_id, sanitize_text, validate_url\n\n__all__ = [\n    'setup_logger',\n    'retry_with_backoff',\n    'validate_comment_id',\n    'validate_user_id',\n    'sanitize_text',\n    'validate_url',\n]\n\n","size_bytes":371}},"version":2}